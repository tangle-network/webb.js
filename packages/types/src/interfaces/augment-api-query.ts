// Auto-generated via `yarn polkadot-types-from-chain`, do not edit
/* eslint-disable */

import type { Bytes, Option, Vec, bool, u32 } from '@polkadot/types';
import type { AnyNumber, ITuple, Observable } from '@polkadot/types/types';
import type { KeyId, Manager, MerkleTree, TreeId } from '@webb-tools/types/interfaces/merkle';
import type { MixerInfo, ScalarData } from '@webb-tools/types/interfaces/mixer';
import type { AccountId, BalanceOf, BlockNumber } from '@webb-tools/types/interfaces/runtime';
import type { ApiTypes } from '@polkadot/api/types';

declare module '@polkadot/api/types/storage' {
  export interface AugmentedQueries<ApiType> {
    merkle: {
      /**
       * Map of cached/past Merkle roots at each block number and group. There
       * can be more than one root update in a single block. Allows for easy
       * pruning since we can remove all keys of the first map past a certain
       * point.
       **/
      cachedRoots: AugmentedQuery<
        ApiType,
        (
          arg1: BlockNumber | AnyNumber | Uint8Array,
          arg2: TreeId | AnyNumber | Uint8Array
        ) => Observable<Vec<ScalarData>>,
        [BlockNumber, TreeId]
      > &
        QueryableStorageEntry<ApiType, [BlockNumber, TreeId]>;
      /**
       * Block number of the newest set of roots that we are caching
       **/
      highestCachedBlock: AugmentedQuery<ApiType, () => Observable<BlockNumber>, []> &
        QueryableStorageEntry<ApiType, []>;
      /**
       * The map of (tree_id, index) to the leaf commitment
       **/
      leaves: AugmentedQuery<
        ApiType,
        (arg1: TreeId | AnyNumber | Uint8Array, arg2: u32 | AnyNumber | Uint8Array) => Observable<ScalarData>,
        [TreeId, u32]
      > &
        QueryableStorageEntry<ApiType, [TreeId, u32]>;
      /**
       * Block number of the oldest set of roots that we are caching
       **/
      lowestCachedBlock: AugmentedQuery<ApiType, () => Observable<BlockNumber>, []> &
        QueryableStorageEntry<ApiType, []>;
      /**
       * Maps tree id to the manager of the tree
       **/
      managers: AugmentedQuery<
        ApiType,
        (arg: TreeId | AnyNumber | Uint8Array) => Observable<Option<Manager>>,
        [TreeId]
      > &
        QueryableStorageEntry<ApiType, [TreeId]>;
      /**
       * The next tree identifier up for grabs
       **/
      nextKeyId: AugmentedQuery<ApiType, () => Observable<KeyId>, []> & QueryableStorageEntry<ApiType, []>;
      /**
       * Old name generated by `decl_event`.
       * The next tree identifier up for grabs
       **/
      nextTreeId: AugmentedQuery<ApiType, () => Observable<TreeId>, []> & QueryableStorageEntry<ApiType, []>;
      /**
       * Indicates whether the group tree is stopped or not
       **/
      stopped: AugmentedQuery<ApiType, (arg: TreeId | AnyNumber | Uint8Array) => Observable<bool>, [TreeId]> &
        QueryableStorageEntry<ApiType, [TreeId]>;
      /**
       * The map of trees to their metadata
       **/
      trees: AugmentedQuery<
        ApiType,
        (arg: TreeId | AnyNumber | Uint8Array) => Observable<Option<MerkleTree>>,
        [TreeId]
      > &
        QueryableStorageEntry<ApiType, [TreeId]>;
      /**
       * Map of used nullifiers for each tree.
       **/
      usedNullifiers: AugmentedQuery<
        ApiType,
        (
          arg: ITuple<[TreeId, ScalarData]> | [TreeId | AnyNumber | Uint8Array, ScalarData | string | Uint8Array]
        ) => Observable<bool>,
        [ITuple<[TreeId, ScalarData]>]
      > &
        QueryableStorageEntry<ApiType, [ITuple<[TreeId, ScalarData]>]>;
      /**
       * The map of trees to their metadata
       **/
      verifyingKeyForTree: AugmentedQuery<
        ApiType,
        (arg: TreeId | AnyNumber | Uint8Array) => Observable<KeyId>,
        [TreeId]
      > &
        QueryableStorageEntry<ApiType, [TreeId]>;
      /**
       * The map of verifying keys for each backend
       **/
      verifyingKeys: AugmentedQuery<
        ApiType,
        (arg: KeyId | AnyNumber | Uint8Array) => Observable<Option<Bytes>>,
        [KeyId]
      > &
        QueryableStorageEntry<ApiType, [KeyId]>;
      /**
       * Generic query
       **/
      [key: string]: QueryableStorageEntry<ApiType>;
    };
    mixer: {
      /**
       * Administrator of the mixer pallet.
       * This account that can stop/start operations of the mixer
       **/
      admin: AugmentedQuery<ApiType, () => Observable<AccountId>, []> & QueryableStorageEntry<ApiType, []>;
      /**
       * Flag indicating if the mixer trees are created
       **/
      firstStageInitialized: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;
      /**
       * The vector of group ids
       **/
      mixerTreeIds: AugmentedQuery<ApiType, () => Observable<Vec<TreeId>>, []> & QueryableStorageEntry<ApiType, []>;
      /**
       * The map of mixer trees to their metadata
       **/
      mixerTrees: AugmentedQuery<ApiType, (arg: TreeId | AnyNumber | Uint8Array) => Observable<MixerInfo>, [TreeId]> &
        QueryableStorageEntry<ApiType, [TreeId]>;
      /**
       * Flag indicating if the mixers are initialized
       **/
      secondStageInitialized: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;
      /**
       * The TVL per group
       **/
      totalValueLocked: AugmentedQuery<
        ApiType,
        (arg: TreeId | AnyNumber | Uint8Array) => Observable<BalanceOf>,
        [TreeId]
      > &
        QueryableStorageEntry<ApiType, [TreeId]>;
      /**
       * Generic query
       **/
      [key: string]: QueryableStorageEntry<ApiType>;
    };
  }

  export interface QueryableStorage<ApiType extends ApiTypes> extends AugmentedQueries<ApiType> {
    [key: string]: QueryableModuleStorage<ApiType>;
  }
}
