// Auto-generated via `yarn polkadot-types-from-chain`, do not edit
/* eslint-disable */

import type { ApiTypes } from '@polkadot/api-base/types';
import type {
  Bytes,
  Compact,
  Null,
  Option,
  U8aFixed,
  Vec,
  bool,
  i128,
  u128,
  u16,
  u32,
  u64,
  u8,
} from '@polkadot/types-codec';
import type { AnyNumber, ITuple } from '@polkadot/types-codec/types';
import type { AccountId32, Call, H256, MultiAddress, Perbill, Percent } from '@polkadot/types/interfaces/runtime';
import type {
  DkgRuntimePrimitivesAggregatedMisbehaviourReports,
  DkgRuntimePrimitivesAggregatedPublicKeys,
  DkgRuntimePrimitivesCryptoPublic,
  DkgRuntimePrimitivesProposal,
  DkgRuntimePrimitivesProposalRefreshProposalSigned,
  EggStandaloneRuntimeOpaqueSessionKeys,
  EggStandaloneRuntimeProtocolSubstrateConfigElement,
  FrameSupportScheduleMaybeHashed,
  PalletAssetRegistryAssetType,
  PalletDemocracyConviction,
  PalletDemocracyVoteAccountVote,
  PalletElectionProviderMultiPhaseRawSolution,
  PalletElectionProviderMultiPhaseSolutionOrSnapshotSize,
  PalletElectionsPhragmenRenouncing,
  PalletLinkableTreeEdgeMetadata,
  PalletStakingRewardDestination,
  PalletStakingValidatorPrefs,
  SpFinalityGrandpaEquivocationProof,
  SpNposElectionsSupport,
  SpRuntimeHeader,
  SpSessionMembershipProof,
  WebbProposalsHeaderResourceId,
  WebbProposalsHeaderTypedChainId,
} from '@polkadot/types/lookup';

declare module '@polkadot/api-base/types/submittable' {
  export interface AugmentedSubmittables<ApiType extends ApiTypes> {
    anchorBn254: {
      create: AugmentedSubmittable<
        (
          depositSize: u128 | AnyNumber | Uint8Array,
          maxEdges: u32 | AnyNumber | Uint8Array,
          depth: u8 | AnyNumber | Uint8Array,
          asset: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u128, u32, u8, u32]
      >;
      deposit: AugmentedSubmittable<
        (
          treeId: u32 | AnyNumber | Uint8Array,
          leaf: EggStandaloneRuntimeProtocolSubstrateConfigElement | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, EggStandaloneRuntimeProtocolSubstrateConfigElement]
      >;
      /**
       * Same as [Self::deposit] but with another call to update the linked
       * anchors cross-chain (if any).
       **/
      depositAndUpdateLinkedAnchors: AugmentedSubmittable<
        (
          treeId: u32 | AnyNumber | Uint8Array,
          leaf: EggStandaloneRuntimeProtocolSubstrateConfigElement | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, EggStandaloneRuntimeProtocolSubstrateConfigElement]
      >;
      withdraw: AugmentedSubmittable<
        (
          id: u32 | AnyNumber | Uint8Array,
          proofBytes: Bytes | string | Uint8Array,
          roots:
            | Vec<EggStandaloneRuntimeProtocolSubstrateConfigElement>
            | (EggStandaloneRuntimeProtocolSubstrateConfigElement | string | Uint8Array)[],
          nullifierHash: EggStandaloneRuntimeProtocolSubstrateConfigElement | string | Uint8Array,
          recipient: AccountId32 | string | Uint8Array,
          relayer: AccountId32 | string | Uint8Array,
          fee: u128 | AnyNumber | Uint8Array,
          refund: u128 | AnyNumber | Uint8Array,
          commitment: EggStandaloneRuntimeProtocolSubstrateConfigElement | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [
          u32,
          Bytes,
          Vec<EggStandaloneRuntimeProtocolSubstrateConfigElement>,
          EggStandaloneRuntimeProtocolSubstrateConfigElement,
          AccountId32,
          AccountId32,
          u128,
          u128,
          EggStandaloneRuntimeProtocolSubstrateConfigElement
        ]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    anchorHandlerBn254: {
      /**
       * This will be called by bridge when proposal to create an
       * anchor has been successfully voted on.
       **/
      executeAnchorCreateProposal: AugmentedSubmittable<
        (
          depositSize: u128 | AnyNumber | Uint8Array,
          srcChainId: u64 | AnyNumber | Uint8Array,
          rId: U8aFixed | string | Uint8Array,
          maxEdges: u32 | AnyNumber | Uint8Array,
          treeDepth: u8 | AnyNumber | Uint8Array,
          asset: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u128, u64, U8aFixed, u32, u8, u32]
      >;
      /**
       * This will be called by bridge when proposal to add/update edge of an
       * anchor has been successfully voted on.
       **/
      executeAnchorUpdateProposal: AugmentedSubmittable<
        (
          rId: U8aFixed | string | Uint8Array,
          anchorMetadata:
            | PalletLinkableTreeEdgeMetadata
            | { srcChainId?: any; root?: any; latestLeafIndex?: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [U8aFixed, PalletLinkableTreeEdgeMetadata]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    anchorVerifierBn254: {
      forceSetParameters: AugmentedSubmittable<
        (parameters: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    assetRegistry: {
      /**
       * Add an asset to an existing pool.
       **/
      addAssetToPool: AugmentedSubmittable<
        (pool: Bytes | string | Uint8Array, assetId: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes, u32]
      >;
      /**
       * Remove an asset from an existing pool.
       **/
      deleteAssetFromPool: AugmentedSubmittable<
        (pool: Bytes | string | Uint8Array, assetId: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes, u32]
      >;
      /**
       * Register a new asset.
       *
       * Asset is identified by `name` and the name must not be used to
       * register another asset.
       *
       * New asset is given `NextAssetId` - sequential asset id
       *
       * Adds mapping between `name` and assigned `asset_id` so asset id can
       * be retrieved by name too (Note: this approach is used in AMM
       * implementation (xyk))
       *
       * Emits 'Registered` event when successful.
       **/
      register: AugmentedSubmittable<
        (
          name: Bytes | string | Uint8Array,
          assetType: PalletAssetRegistryAssetType | { Token: any } | { PoolShare: any } | string | Uint8Array,
          existentialDeposit: u128 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Bytes, PalletAssetRegistryAssetType, u128]
      >;
      /**
       * Set asset native location.
       *
       * Adds mapping between native location and local asset id and vice
       * versa.
       *
       * Mainly used in XCM.
       *
       * Emits `LocationSet` event when successful.
       **/
      setLocation: AugmentedSubmittable<
        (assetId: u32 | AnyNumber | Uint8Array, location: Null | null) => SubmittableExtrinsic<ApiType>,
        [u32, Null]
      >;
      /**
       * Set metadata for an asset.
       *
       * - `asset_id`: Asset identifier.
       * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
       * - `decimals`: The number of decimals this asset uses to represent one unit.
       *
       * Emits `MetadataSet` event when successful.
       **/
      setMetadata: AugmentedSubmittable<
        (
          assetId: u32 | AnyNumber | Uint8Array,
          symbol: Bytes | string | Uint8Array,
          decimals: u8 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, Bytes, u8]
      >;
      /**
       * Update registered asset.
       *
       * Updates also mapping between name and asset id if provided name is
       * different than currently registered.
       *
       * Emits `Updated` event when successful.
       **/
      update: AugmentedSubmittable<
        (
          assetId: u32 | AnyNumber | Uint8Array,
          name: Bytes | string | Uint8Array,
          assetType: PalletAssetRegistryAssetType | { Token: any } | { PoolShare: any } | string | Uint8Array,
          existentialDeposit: Option<u128> | null | object | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, Bytes, PalletAssetRegistryAssetType, Option<u128>]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    authorship: {
      /**
       * Provide a set of uncles.
       **/
      setUncles: AugmentedSubmittable<
        (
          newUncles:
            | Vec<SpRuntimeHeader>
            | (
                | SpRuntimeHeader
                | { parentHash?: any; number?: any; stateRoot?: any; extrinsicsRoot?: any; digest?: any }
                | string
                | Uint8Array
              )[]
        ) => SubmittableExtrinsic<ApiType>,
        [Vec<SpRuntimeHeader>]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    bagsList: {
      /**
       * Move the caller's Id directly in front of `lighter`.
       *
       * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
       * the account going in front of `lighter`.
       *
       * Only works if
       * - both nodes are within the same bag,
       * - and `origin` has a greater `VoteWeight` than `lighter`.
       **/
      putInFrontOf: AugmentedSubmittable<
        (lighter: AccountId32 | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [AccountId32]
      >;
      /**
       * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
       * changed its weight that it should properly fall into a different bag than its current
       * one.
       *
       * Anyone can call this function about any potentially dislocated account.
       *
       * Will never return an error; if `dislocated` does not exist or doesn't need a rebag, then
       * it is a noop and fees are still collected from `origin`.
       **/
      rebag: AugmentedSubmittable<
        (dislocated: AccountId32 | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [AccountId32]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    balances: {
      /**
       * Exactly as `transfer`, except the origin must be root and the source account may be
       * specified.
       * # <weight>
       * - Same as transfer, but additional read and write because the source account is not
       * assumed to be in the overlay.
       * # </weight>
       **/
      forceTransfer: AugmentedSubmittable<
        (
          source:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          dest:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          value: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, MultiAddress, Compact<u128>]
      >;
      /**
       * Unreserve some balance from a user by force.
       *
       * Can only be called by ROOT.
       **/
      forceUnreserve: AugmentedSubmittable<
        (
          who:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          amount: u128 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, u128]
      >;
      /**
       * Set the balances of a given account.
       *
       * This will alter `FreeBalance` and `ReservedBalance` in storage. it will
       * also alter the total issuance of the system (`TotalIssuance`) appropriately.
       * If the new free or reserved balance is below the existential deposit,
       * it will reset the account nonce (`frame_system::AccountNonce`).
       *
       * The dispatch origin for this call is `root`.
       **/
      setBalance: AugmentedSubmittable<
        (
          who:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          newFree: Compact<u128> | AnyNumber | Uint8Array,
          newReserved: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, Compact<u128>, Compact<u128>]
      >;
      /**
       * Transfer some liquid free balance to another account.
       *
       * `transfer` will set the `FreeBalance` of the sender and receiver.
       * If the sender's account is below the existential deposit as a result
       * of the transfer, the account will be reaped.
       *
       * The dispatch origin for this call must be `Signed` by the transactor.
       *
       * # <weight>
       * - Dependent on arguments but not critical, given proper implementations for input config
       * types. See related functions below.
       * - It contains a limited number of reads and writes internally and no complex
       * computation.
       *
       * Related functions:
       *
       * - `ensure_can_withdraw` is always called internally but has a bounded complexity.
       * - Transferring balances to accounts that did not exist before will cause
       * `T::OnNewAccount::on_new_account` to be called.
       * - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
       * - `transfer_keep_alive` works the same way as `transfer`, but has an additional check
       * that the transfer will not kill the origin account.
       * ---------------------------------
       * - Origin account is already in memory, so no DB operations for them.
       * # </weight>
       **/
      transfer: AugmentedSubmittable<
        (
          dest:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          value: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, Compact<u128>]
      >;
      /**
       * Transfer the entire transferable balance from the caller account.
       *
       * NOTE: This function only attempts to transfer _transferable_ balances. This means that
       * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
       * transferred by this function. To ensure that this function results in a killed account,
       * you might need to prepare the account by removing any reference counters, storage
       * deposits, etc...
       *
       * The dispatch origin of this call must be Signed.
       *
       * - `dest`: The recipient of the transfer.
       * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
       * of the funds the account has, causing the sender account to be killed (false), or
       * transfer everything except at least the existential deposit, which will guarantee to
       * keep the sender account alive (true). # <weight>
       * - O(1). Just like transfer, but reading the user's transferable balance first.
       * #</weight>
       **/
      transferAll: AugmentedSubmittable<
        (
          dest:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          keepAlive: bool | boolean | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, bool]
      >;
      /**
       * Same as the [`transfer`] call, but with a check that the transfer will not kill the
       * origin account.
       *
       * 99% of the time you want [`transfer`] instead.
       *
       * [`transfer`]: struct.Pallet.html#method.transfer
       **/
      transferKeepAlive: AugmentedSubmittable<
        (
          dest:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          value: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, Compact<u128>]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    bounties: {
      /**
       * Accept the curator role for a bounty.
       * A deposit will be reserved from curator and refund upon successful payout.
       *
       * May only be called from the curator.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       **/
      acceptCurator: AugmentedSubmittable<
        (bountyId: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>]
      >;
      /**
       * Approve a bounty proposal. At a later time, the bounty will be funded and become active
       * and the original deposit will be returned.
       *
       * May only be called from `T::ApproveOrigin`.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       **/
      approveBounty: AugmentedSubmittable<
        (bountyId: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>]
      >;
      /**
       * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
       * after a delay.
       *
       * The dispatch origin for this call must be the curator of this bounty.
       *
       * - `bounty_id`: Bounty ID to award.
       * - `beneficiary`: The beneficiary account whom will receive the payout.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       **/
      awardBounty: AugmentedSubmittable<
        (
          bountyId: Compact<u32> | AnyNumber | Uint8Array,
          beneficiary:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, MultiAddress]
      >;
      /**
       * Claim the payout from an awarded bounty after payout delay.
       *
       * The dispatch origin for this call must be the beneficiary of this bounty.
       *
       * - `bounty_id`: Bounty ID to claim.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       **/
      claimBounty: AugmentedSubmittable<
        (bountyId: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>]
      >;
      /**
       * Cancel a proposed or active bounty. All the funds will be sent to treasury and
       * the curator deposit will be unreserved if possible.
       *
       * Only `T::RejectOrigin` is able to cancel a bounty.
       *
       * - `bounty_id`: Bounty ID to cancel.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       **/
      closeBounty: AugmentedSubmittable<
        (bountyId: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>]
      >;
      /**
       * Extend the expiry time of an active bounty.
       *
       * The dispatch origin for this call must be the curator of this bounty.
       *
       * - `bounty_id`: Bounty ID to extend.
       * - `remark`: additional information.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       **/
      extendBountyExpiry: AugmentedSubmittable<
        (
          bountyId: Compact<u32> | AnyNumber | Uint8Array,
          remark: Bytes | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, Bytes]
      >;
      /**
       * Propose a new bounty.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
       * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
       * or slashed when rejected.
       *
       * - `curator`: The curator account whom will manage this bounty.
       * - `fee`: The curator fee.
       * - `value`: The total payment amount of this bounty, curator fee included.
       * - `description`: The description of this bounty.
       **/
      proposeBounty: AugmentedSubmittable<
        (
          value: Compact<u128> | AnyNumber | Uint8Array,
          description: Bytes | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u128>, Bytes]
      >;
      /**
       * Assign a curator to a funded bounty.
       *
       * May only be called from `T::ApproveOrigin`.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       **/
      proposeCurator: AugmentedSubmittable<
        (
          bountyId: Compact<u32> | AnyNumber | Uint8Array,
          curator:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          fee: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, MultiAddress, Compact<u128>]
      >;
      /**
       * Unassign curator from a bounty.
       *
       * This function can only be called by the `RejectOrigin` a signed origin.
       *
       * If this function is called by the `RejectOrigin`, we assume that the curator is
       * malicious or inactive. As a result, we will slash the curator when possible.
       *
       * If the origin is the curator, we take this as a sign they are unable to do their job and
       * they willingly give up. We could slash them, but for now we allow them to recover their
       * deposit and exit without issue. (We may want to change this if it is abused.)
       *
       * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
       * anyone in the community to call out that a curator is not doing their due diligence, and
       * we should pick a new curator. In this case the curator should also be slashed.
       *
       * # <weight>
       * - O(1).
       * # </weight>
       **/
      unassignCurator: AugmentedSubmittable<
        (bountyId: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    bridge: {
      /**
       * @param origin
       * @param src_id
       * @param call: the dispatchable call corresponding to a
       * handler function
       * @param proposal_data: (r_id, nonce, 4 bytes of zeroes, call)
       * @param signature: a signature over the proposal_data
       *
       * We check:
       * 1. That the signature is actually over the proposal data
       * 2. That the r_id parsed from the proposal data exists
       * 3. That the call from the proposal data and the call input parameter to the function are
       * consistent with each other 4. That the execution chain id type parsed from the r_id is
       * indeed this chain's id type
       *
       * If all these checks pass then we call finalize_execution which actually executes the
       * dispatchable call. The dispatchable call is usually a handler function, for instance in
       * the anchor-handler or token-wrapper-handler pallet.
       *
       * There are a few TODOs left in the function.
       *
       * In the execute_proposal
       * # <weight>
       * - weight of proposed call, regardless of whether execution is performed
       * # </weight>
       **/
      executeProposal: AugmentedSubmittable<
        (
          srcId: u64 | AnyNumber | Uint8Array,
          call: Call | { callIndex?: any; args?: any } | string | Uint8Array,
          proposalData: Bytes | string | Uint8Array,
          signature: Bytes | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u64, Call, Bytes, Bytes]
      >;
      forceSetMaintainer: AugmentedSubmittable<
        (newMaintainer: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes]
      >;
      /**
       * Removes a resource ID from the resource mapping.
       *
       * After this call, bridge transfers with the associated resource ID
       * will be rejected.
       *
       * # <weight>
       * - O(1) removal
       * # </weight>
       **/
      removeResource: AugmentedSubmittable<
        (id: U8aFixed | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [U8aFixed]
      >;
      /**
       * Sets the maintainer.
       **/
      setMaintainer: AugmentedSubmittable<
        (message: Bytes | string | Uint8Array, signature: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes, Bytes]
      >;
      /**
       * Stores a method name on chain under an associated resource ID.
       *
       * # <weight>
       * - O(1) write
       * # </weight>
       **/
      setResource: AugmentedSubmittable<
        (id: U8aFixed | string | Uint8Array, method: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [U8aFixed, Bytes]
      >;
      /**
       * Enables a chain ID as a source or destination for a bridge transfer.
       *
       * # <weight>
       * - O(1) lookup and insert
       * # </weight>
       **/
      whitelistChain: AugmentedSubmittable<(id: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    childBounties: {
      /**
       * Accept the curator role for the child-bounty.
       *
       * The dispatch origin for this call must be the curator of this
       * child-bounty.
       *
       * A deposit will be reserved from the curator and refund upon
       * successful payout or cancellation.
       *
       * Fee for curator is deducted from curator fee of parent bounty.
       *
       * Parent bounty must be in active state, for this child-bounty call to
       * work.
       *
       * Child-bounty must be in "CuratorProposed" state, for processing the
       * call. And state of child-bounty is moved to "Active" on successful
       * call completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       **/
      acceptCurator: AugmentedSubmittable<
        (
          parentBountyId: Compact<u32> | AnyNumber | Uint8Array,
          childBountyId: Compact<u32> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, Compact<u32>]
      >;
      /**
       * Add a new child-bounty.
       *
       * The dispatch origin for this call must be the curator of parent
       * bounty and the parent bounty must be in "active" state.
       *
       * Child-bounty gets added successfully & fund gets transferred from
       * parent bounty to child-bounty account, if parent bounty has enough
       * funds, else the call fails.
       *
       * Upper bound to maximum number of active  child-bounties that can be
       * added are managed via runtime trait config
       * [`Config::MaxActiveChildBountyCount`].
       *
       * If the call is success, the status of child-bounty is updated to
       * "Added".
       *
       * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
       * - `value`: Value for executing the proposal.
       * - `description`: Text description for the child-bounty.
       **/
      addChildBounty: AugmentedSubmittable<
        (
          parentBountyId: Compact<u32> | AnyNumber | Uint8Array,
          value: Compact<u128> | AnyNumber | Uint8Array,
          description: Bytes | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, Compact<u128>, Bytes]
      >;
      /**
       * Award child-bounty to a beneficiary.
       *
       * The beneficiary will be able to claim the funds after a delay.
       *
       * The dispatch origin for this call must be the master curator or
       * curator of this child-bounty.
       *
       * Parent bounty must be in active state, for this child-bounty call to
       * work.
       *
       * Child-bounty must be in active state, for processing the call. And
       * state of child-bounty is moved to "PendingPayout" on successful call
       * completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       * - `beneficiary`: Beneficiary account.
       **/
      awardChildBounty: AugmentedSubmittable<
        (
          parentBountyId: Compact<u32> | AnyNumber | Uint8Array,
          childBountyId: Compact<u32> | AnyNumber | Uint8Array,
          beneficiary:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, Compact<u32>, MultiAddress]
      >;
      /**
       * Claim the payout from an awarded child-bounty after payout delay.
       *
       * The dispatch origin for this call may be any signed origin.
       *
       * Call works independent of parent bounty state, No need for parent
       * bounty to be in active state.
       *
       * The Beneficiary is paid out with agreed bounty value. Curator fee is
       * paid & curator deposit is unreserved.
       *
       * Child-bounty must be in "PendingPayout" state, for processing the
       * call. And instance of child-bounty is removed from the state on
       * successful call completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       **/
      claimChildBounty: AugmentedSubmittable<
        (
          parentBountyId: Compact<u32> | AnyNumber | Uint8Array,
          childBountyId: Compact<u32> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, Compact<u32>]
      >;
      /**
       * Cancel a proposed or active child-bounty. Child-bounty account funds
       * are transferred to parent bounty account. The child-bounty curator
       * deposit may be unreserved if possible.
       *
       * The dispatch origin for this call must be either parent curator or
       * `T::RejectOrigin`.
       *
       * If the state of child-bounty is `Active`, curator deposit is
       * unreserved.
       *
       * If the state of child-bounty is `PendingPayout`, call fails &
       * returns `PendingPayout` error.
       *
       * For the origin other than T::RejectOrigin, parent bounty must be in
       * active state, for this child-bounty call to work. For origin
       * T::RejectOrigin execution is forced.
       *
       * Instance of child-bounty is removed from the state on successful
       * call completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       **/
      closeChildBounty: AugmentedSubmittable<
        (
          parentBountyId: Compact<u32> | AnyNumber | Uint8Array,
          childBountyId: Compact<u32> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, Compact<u32>]
      >;
      /**
       * Propose curator for funded child-bounty.
       *
       * The dispatch origin for this call must be curator of parent bounty.
       *
       * Parent bounty must be in active state, for this child-bounty call to
       * work.
       *
       * Child-bounty must be in "Added" state, for processing the call. And
       * state of child-bounty is moved to "CuratorProposed" on successful
       * call completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       * - `curator`: Address of child-bounty curator.
       * - `fee`: payment fee to child-bounty curator for execution.
       **/
      proposeCurator: AugmentedSubmittable<
        (
          parentBountyId: Compact<u32> | AnyNumber | Uint8Array,
          childBountyId: Compact<u32> | AnyNumber | Uint8Array,
          curator:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          fee: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, Compact<u32>, MultiAddress, Compact<u128>]
      >;
      /**
       * Unassign curator from a child-bounty.
       *
       * The dispatch origin for this call can be either `RejectOrigin`, or
       * the curator of the parent bounty, or any signed origin.
       *
       * For the origin other than T::RejectOrigin and the child-bounty
       * curator, parent-bounty must be in active state, for this call to
       * work. We allow child-bounty curator and T::RejectOrigin to execute
       * this call irrespective of the parent-bounty state.
       *
       * If this function is called by the `RejectOrigin` or the
       * parent-bounty curator, we assume that the child-bounty curator is
       * malicious or inactive. As a result, child-bounty curator deposit is
       * slashed.
       *
       * If the origin is the child-bounty curator, we take this as a sign
       * that they are unable to do their job, and are willingly giving up.
       * We could slash the deposit, but for now we allow them to unreserve
       * their deposit and exit without issue. (We may want to change this if
       * it is abused.)
       *
       * Finally, the origin can be anyone iff the child-bounty curator is
       * "inactive". Expiry update due of parent bounty is used to estimate
       * inactive state of child-bounty curator.
       *
       * This allows anyone in the community to call out that a child-bounty
       * curator is not doing their due diligence, and we should pick a new
       * one. In this case the child-bounty curator deposit is slashed.
       *
       * State of child-bounty is moved to Added state on successful call
       * completion.
       *
       * - `parent_bounty_id`: Index of parent bounty.
       * - `child_bounty_id`: Index of child bounty.
       **/
      unassignCurator: AugmentedSubmittable<
        (
          parentBountyId: Compact<u32> | AnyNumber | Uint8Array,
          childBountyId: Compact<u32> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, Compact<u32>]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    council: {
      /**
       * Close a vote that is either approved, disapproved or whose voting period has ended.
       *
       * May be called by any signed account in order to finish voting and close the proposal.
       *
       * If called before the end of the voting period it will only close the vote if it is
       * has enough votes to be approved or disapproved.
       *
       * If called after the end of the voting period abstentions are counted as rejections
       * unless there is a prime member set and the prime member cast an approval.
       *
       * If the close operation completes successfully with disapproval, the transaction fee will
       * be waived. Otherwise execution of the approved operation will be charged to the caller.
       *
       * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
       * proposal.
       * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
       * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
       *
       * # <weight>
       * ## Weight
       * - `O(B + M + P1 + P2)` where:
       * - `B` is `proposal` size in bytes (length-fee-bounded)
       * - `M` is members-count (code- and governance-bounded)
       * - `P1` is the complexity of `proposal` preimage.
       * - `P2` is proposal-count (code-bounded)
       * - DB:
       * - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
       * - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
       * `O(P2)`)
       * - any mutations done while executing `proposal` (`P1`)
       * - up to 3 events
       * # </weight>
       **/
      close: AugmentedSubmittable<
        (
          proposalHash: H256 | string | Uint8Array,
          index: Compact<u32> | AnyNumber | Uint8Array,
          proposalWeightBound: Compact<u64> | AnyNumber | Uint8Array,
          lengthBound: Compact<u32> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [H256, Compact<u32>, Compact<u64>, Compact<u32>]
      >;
      /**
       * Disapprove a proposal, close, and remove it from the system, regardless of its current
       * state.
       *
       * Must be called by the Root origin.
       *
       * Parameters:
       * * `proposal_hash`: The hash of the proposal that should be disapproved.
       *
       * # <weight>
       * Complexity: O(P) where P is the number of max proposals
       * DB Weight:
       * * Reads: Proposals
       * * Writes: Voting, Proposals, ProposalOf
       * # </weight>
       **/
      disapproveProposal: AugmentedSubmittable<
        (proposalHash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [H256]
      >;
      /**
       * Dispatch a proposal from a member using the `Member` origin.
       *
       * Origin must be a member of the collective.
       *
       * # <weight>
       * ## Weight
       * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
       * `proposal`
       * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
       * - 1 event
       * # </weight>
       **/
      execute: AugmentedSubmittable<
        (
          proposal: Call | { callIndex?: any; args?: any } | string | Uint8Array,
          lengthBound: Compact<u32> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Call, Compact<u32>]
      >;
      /**
       * Add a new proposal to either be voted on or executed directly.
       *
       * Requires the sender to be member.
       *
       * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
       * or put up for voting.
       *
       * # <weight>
       * ## Weight
       * - `O(B + M + P1)` or `O(B + M + P2)` where:
       * - `B` is `proposal` size in bytes (length-fee-bounded)
       * - `M` is members-count (code- and governance-bounded)
       * - branching is influenced by `threshold` where:
       * - `P1` is proposal execution complexity (`threshold < 2`)
       * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
       * - DB:
       * - 1 storage read `is_member` (codec `O(M)`)
       * - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
       * - DB accesses influenced by `threshold`:
       * - EITHER storage accesses done by `proposal` (`threshold < 2`)
       * - OR proposal insertion (`threshold <= 2`)
       * - 1 storage mutation `Proposals` (codec `O(P2)`)
       * - 1 storage mutation `ProposalCount` (codec `O(1)`)
       * - 1 storage write `ProposalOf` (codec `O(B)`)
       * - 1 storage write `Voting` (codec `O(M)`)
       * - 1 event
       * # </weight>
       **/
      propose: AugmentedSubmittable<
        (
          threshold: Compact<u32> | AnyNumber | Uint8Array,
          proposal: Call | { callIndex?: any; args?: any } | string | Uint8Array,
          lengthBound: Compact<u32> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, Call, Compact<u32>]
      >;
      /**
       * Set the collective's membership.
       *
       * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
       * - `prime`: The prime member whose vote sets the default.
       * - `old_count`: The upper bound for the previous number of members in storage. Used for
       * weight estimation.
       *
       * Requires root origin.
       *
       * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
       * the weight estimations rely on it to estimate dispatchable weight.
       *
       * # WARNING:
       *
       * The `pallet-collective` can also be managed by logic outside of the pallet through the
       * implementation of the trait [`ChangeMembers`].
       * Any call to `set_members` must be careful that the member set doesn't get out of sync
       * with other logic managing the member set.
       *
       * # <weight>
       * ## Weight
       * - `O(MP + N)` where:
       * - `M` old-members-count (code- and governance-bounded)
       * - `N` new-members-count (code- and governance-bounded)
       * - `P` proposals-count (code-bounded)
       * - DB:
       * - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the
       * members
       * - 1 storage read (codec `O(P)`) for reading the proposals
       * - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
       * - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
       * # </weight>
       **/
      setMembers: AugmentedSubmittable<
        (
          newMembers: Vec<AccountId32> | (AccountId32 | string | Uint8Array)[],
          prime: Option<AccountId32> | null | object | string | Uint8Array,
          oldCount: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Vec<AccountId32>, Option<AccountId32>, u32]
      >;
      /**
       * Add an aye or nay vote for the sender to the given proposal.
       *
       * Requires the sender to be a member.
       *
       * Transaction fees will be waived if the member is voting on any particular proposal
       * for the first time and the call is successful. Subsequent vote changes will charge a
       * fee.
       * # <weight>
       * ## Weight
       * - `O(M)` where `M` is members-count (code- and governance-bounded)
       * - DB:
       * - 1 storage read `Members` (codec `O(M)`)
       * - 1 storage mutation `Voting` (codec `O(M)`)
       * - 1 event
       * # </weight>
       **/
      vote: AugmentedSubmittable<
        (
          proposal: H256 | string | Uint8Array,
          index: Compact<u32> | AnyNumber | Uint8Array,
          approve: bool | boolean | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [H256, Compact<u32>, bool]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    currencies: {
      /**
       * Transfer some balance to another account under `currency_id`.
       *
       * The dispatch origin for this call must be `Signed` by the
       * transactor.
       **/
      transfer: AugmentedSubmittable<
        (
          dest:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          currencyId: u32 | AnyNumber | Uint8Array,
          amount: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, u32, Compact<u128>]
      >;
      /**
       * Transfer some native currency to another account.
       *
       * The dispatch origin for this call must be `Signed` by the
       * transactor.
       **/
      transferNativeCurrency: AugmentedSubmittable<
        (
          dest:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          amount: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, Compact<u128>]
      >;
      /**
       * update amount of account `who` under `currency_id`.
       *
       * The dispatch origin of this call must be _Root_.
       **/
      updateBalance: AugmentedSubmittable<
        (
          who:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          currencyId: u32 | AnyNumber | Uint8Array,
          amount: i128 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, u32, i128]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    democracy: {
      /**
       * Permanently place a proposal into the blacklist. This prevents it from ever being
       * proposed again.
       *
       * If called on a queued public or external proposal, then this will result in it being
       * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
       * then it will be cancelled.
       *
       * The dispatch origin of this call must be `BlacklistOrigin`.
       *
       * - `proposal_hash`: The proposal hash to blacklist permanently.
       * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
       * cancelled.
       *
       * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
       * reasonable value).
       **/
      blacklist: AugmentedSubmittable<
        (
          proposalHash: H256 | string | Uint8Array,
          maybeRefIndex: Option<u32> | null | object | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [H256, Option<u32>]
      >;
      /**
       * Remove a proposal.
       *
       * The dispatch origin of this call must be `CancelProposalOrigin`.
       *
       * - `prop_index`: The index of the proposal to cancel.
       *
       * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
       **/
      cancelProposal: AugmentedSubmittable<
        (propIndex: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>]
      >;
      /**
       * Cancel a proposal queued for enactment.
       *
       * The dispatch origin of this call must be _Root_.
       *
       * - `which`: The index of the referendum to cancel.
       *
       * Weight: `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`.
       **/
      cancelQueued: AugmentedSubmittable<(which: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32]>;
      /**
       * Remove a referendum.
       *
       * The dispatch origin of this call must be _Root_.
       *
       * - `ref_index`: The index of the referendum to cancel.
       *
       * # Weight: `O(1)`.
       **/
      cancelReferendum: AugmentedSubmittable<
        (refIndex: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>]
      >;
      /**
       * Clears all public proposals.
       *
       * The dispatch origin of this call must be _Root_.
       *
       * Weight: `O(1)`.
       **/
      clearPublicProposals: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
      /**
       * Delegate the voting power (with some given conviction) of the sending account.
       *
       * The balance delegated is locked for as long as it's delegated, and thereafter for the
       * time appropriate for the conviction's lock period.
       *
       * The dispatch origin of this call must be _Signed_, and the signing account must either:
       * - be delegating already; or
       * - have no voting activity (if there is, then it will need to be removed/consolidated
       * through `reap_vote` or `unvote`).
       *
       * - `to`: The account whose voting the `target` account's voting power will follow.
       * - `conviction`: The conviction that will be attached to the delegated votes. When the
       * account is undelegated, the funds will be locked for the corresponding period.
       * - `balance`: The amount of the account's balance to be used in delegating. This must not
       * be more than the account's current balance.
       *
       * Emits `Delegated`.
       *
       * Weight: `O(R)` where R is the number of referendums the voter delegating to has
       * voted on. Weight is charged as if maximum votes.
       **/
      delegate: AugmentedSubmittable<
        (
          to: AccountId32 | string | Uint8Array,
          conviction:
            | PalletDemocracyConviction
            | 'None'
            | 'Locked1x'
            | 'Locked2x'
            | 'Locked3x'
            | 'Locked4x'
            | 'Locked5x'
            | 'Locked6x'
            | number
            | Uint8Array,
          balance: u128 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [AccountId32, PalletDemocracyConviction, u128]
      >;
      /**
       * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
       * referendum.
       *
       * The dispatch origin of this call must be `CancellationOrigin`.
       *
       * -`ref_index`: The index of the referendum to cancel.
       *
       * Weight: `O(1)`.
       **/
      emergencyCancel: AugmentedSubmittable<
        (refIndex: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [u32]
      >;
      /**
       * Enact a proposal from a referendum. For now we just make the weight be the maximum.
       **/
      enactProposal: AugmentedSubmittable<
        (
          proposalHash: H256 | string | Uint8Array,
          index: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [H256, u32]
      >;
      /**
       * Schedule a referendum to be tabled once it is legal to schedule an external
       * referendum.
       *
       * The dispatch origin of this call must be `ExternalOrigin`.
       *
       * - `proposal_hash`: The preimage hash of the proposal.
       *
       * Weight: `O(V)` with V number of vetoers in the blacklist of proposal.
       * Decoding vec of length V. Charged as maximum
       **/
      externalPropose: AugmentedSubmittable<
        (proposalHash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [H256]
      >;
      /**
       * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
       * schedule an external referendum.
       *
       * The dispatch of this call must be `ExternalDefaultOrigin`.
       *
       * - `proposal_hash`: The preimage hash of the proposal.
       *
       * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
       * pre-scheduled `external_propose` call.
       *
       * Weight: `O(1)`
       **/
      externalProposeDefault: AugmentedSubmittable<
        (proposalHash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [H256]
      >;
      /**
       * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
       * an external referendum.
       *
       * The dispatch of this call must be `ExternalMajorityOrigin`.
       *
       * - `proposal_hash`: The preimage hash of the proposal.
       *
       * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
       * pre-scheduled `external_propose` call.
       *
       * Weight: `O(1)`
       **/
      externalProposeMajority: AugmentedSubmittable<
        (proposalHash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [H256]
      >;
      /**
       * Schedule the currently externally-proposed majority-carries referendum to be tabled
       * immediately. If there is no externally-proposed referendum currently, or if there is one
       * but it is not a majority-carries referendum then it fails.
       *
       * The dispatch of this call must be `FastTrackOrigin`.
       *
       * - `proposal_hash`: The hash of the current external proposal.
       * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
       * `FastTrackVotingPeriod` if too low.
       * - `delay`: The number of block after voting has ended in approval and this should be
       * enacted. This doesn't have a minimum amount.
       *
       * Emits `Started`.
       *
       * Weight: `O(1)`
       **/
      fastTrack: AugmentedSubmittable<
        (
          proposalHash: H256 | string | Uint8Array,
          votingPeriod: u32 | AnyNumber | Uint8Array,
          delay: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [H256, u32, u32]
      >;
      /**
       * Register the preimage for an upcoming proposal. This requires the proposal to be
       * in the dispatch queue. No deposit is needed. When this call is successful, i.e.
       * the preimage has not been uploaded before and matches some imminent proposal,
       * no fee is paid.
       *
       * The dispatch origin of this call must be _Signed_.
       *
       * - `encoded_proposal`: The preimage of a proposal.
       *
       * Emits `PreimageNoted`.
       *
       * Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit).
       **/
      noteImminentPreimage: AugmentedSubmittable<
        (encodedProposal: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes]
      >;
      /**
       * Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`.
       **/
      noteImminentPreimageOperational: AugmentedSubmittable<
        (encodedProposal: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes]
      >;
      /**
       * Register the preimage for an upcoming proposal. This doesn't require the proposal to be
       * in the dispatch queue but does require a deposit, returned once enacted.
       *
       * The dispatch origin of this call must be _Signed_.
       *
       * - `encoded_proposal`: The preimage of a proposal.
       *
       * Emits `PreimageNoted`.
       *
       * Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit).
       **/
      notePreimage: AugmentedSubmittable<
        (encodedProposal: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes]
      >;
      /**
       * Same as `note_preimage` but origin is `OperationalPreimageOrigin`.
       **/
      notePreimageOperational: AugmentedSubmittable<
        (encodedProposal: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes]
      >;
      /**
       * Propose a sensitive action to be taken.
       *
       * The dispatch origin of this call must be _Signed_ and the sender must
       * have funds to cover the deposit.
       *
       * - `proposal_hash`: The hash of the proposal preimage.
       * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
       *
       * Emits `Proposed`.
       *
       * Weight: `O(p)`
       **/
      propose: AugmentedSubmittable<
        (
          proposalHash: H256 | string | Uint8Array,
          value: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [H256, Compact<u128>]
      >;
      /**
       * Remove an expired proposal preimage and collect the deposit.
       *
       * The dispatch origin of this call must be _Signed_.
       *
       * - `proposal_hash`: The preimage hash of a proposal.
       * - `proposal_length_upper_bound`: an upper bound on length of the proposal. Extrinsic is
       * weighted according to this value with no refund.
       *
       * This will only work after `VotingPeriod` blocks from the time that the preimage was
       * noted, if it's the same account doing it. If it's a different account, then it'll only
       * work an additional `EnactmentPeriod` later.
       *
       * Emits `PreimageReaped`.
       *
       * Weight: `O(D)` where D is length of proposal.
       **/
      reapPreimage: AugmentedSubmittable<
        (
          proposalHash: H256 | string | Uint8Array,
          proposalLenUpperBound: Compact<u32> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [H256, Compact<u32>]
      >;
      /**
       * Remove a vote for a referendum.
       *
       * If the `target` is equal to the signer, then this function is exactly equivalent to
       * `remove_vote`. If not equal to the signer, then the vote must have expired,
       * either because the referendum was cancelled, because the voter lost the referendum or
       * because the conviction period is over.
       *
       * The dispatch origin of this call must be _Signed_.
       *
       * - `target`: The account of the vote to be removed; this account must have voted for
       * referendum `index`.
       * - `index`: The index of referendum of the vote to be removed.
       *
       * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
       * Weight is calculated for the maximum number of vote.
       **/
      removeOtherVote: AugmentedSubmittable<
        (
          target: AccountId32 | string | Uint8Array,
          index: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [AccountId32, u32]
      >;
      /**
       * Remove a vote for a referendum.
       *
       * If:
       * - the referendum was cancelled, or
       * - the referendum is ongoing, or
       * - the referendum has ended such that
       * - the vote of the account was in opposition to the result; or
       * - there was no conviction to the account's vote; or
       * - the account made a split vote
       * ...then the vote is removed cleanly and a following call to `unlock` may result in more
       * funds being available.
       *
       * If, however, the referendum has ended and:
       * - it finished corresponding to the vote of the account, and
       * - the account made a standard vote with conviction, and
       * - the lock period of the conviction is not over
       * ...then the lock will be aggregated into the overall account's lock, which may involve
       * *overlocking* (where the two locks are combined into a single lock that is the maximum
       * of both the amount locked and the time is it locked for).
       *
       * The dispatch origin of this call must be _Signed_, and the signer must have a vote
       * registered for referendum `index`.
       *
       * - `index`: The index of referendum of the vote to be removed.
       *
       * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
       * Weight is calculated for the maximum number of vote.
       **/
      removeVote: AugmentedSubmittable<(index: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32]>;
      /**
       * Signals agreement with a particular proposal.
       *
       * The dispatch origin of this call must be _Signed_ and the sender
       * must have funds to cover the deposit, equal to the original deposit.
       *
       * - `proposal`: The index of the proposal to second.
       * - `seconds_upper_bound`: an upper bound on the current number of seconds on this
       * proposal. Extrinsic is weighted according to this value with no refund.
       *
       * Weight: `O(S)` where S is the number of seconds a proposal already has.
       **/
      second: AugmentedSubmittable<
        (
          proposal: Compact<u32> | AnyNumber | Uint8Array,
          secondsUpperBound: Compact<u32> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, Compact<u32>]
      >;
      /**
       * Undelegate the voting power of the sending account.
       *
       * Tokens may be unlocked following once an amount of time consistent with the lock period
       * of the conviction with which the delegation was issued.
       *
       * The dispatch origin of this call must be _Signed_ and the signing account must be
       * currently delegating.
       *
       * Emits `Undelegated`.
       *
       * Weight: `O(R)` where R is the number of referendums the voter delegating to has
       * voted on. Weight is charged as if maximum votes.
       **/
      undelegate: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
      /**
       * Unlock tokens that have an expired lock.
       *
       * The dispatch origin of this call must be _Signed_.
       *
       * - `target`: The account to remove the lock on.
       *
       * Weight: `O(R)` with R number of vote of target.
       **/
      unlock: AugmentedSubmittable<
        (target: AccountId32 | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [AccountId32]
      >;
      /**
       * Veto and blacklist the external proposal hash.
       *
       * The dispatch origin of this call must be `VetoOrigin`.
       *
       * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
       *
       * Emits `Vetoed`.
       *
       * Weight: `O(V + log(V))` where V is number of `existing vetoers`
       **/
      vetoExternal: AugmentedSubmittable<
        (proposalHash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [H256]
      >;
      /**
       * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
       * otherwise it is a vote to keep the status quo.
       *
       * The dispatch origin of this call must be _Signed_.
       *
       * - `ref_index`: The index of the referendum to vote for.
       * - `vote`: The vote configuration.
       *
       * Weight: `O(R)` where R is the number of referendums the voter has voted on.
       **/
      vote: AugmentedSubmittable<
        (
          refIndex: Compact<u32> | AnyNumber | Uint8Array,
          vote: PalletDemocracyVoteAccountVote | { Standard: any } | { Split: any } | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, PalletDemocracyVoteAccountVote]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    dkg: {
      /**
       * Forcefully rotate the DKG
       *
       * This forces the next authorities into the current authority spot and
       * automatically increments the authority ID. It uses `change_authorities`
       * to execute the rotation forcefully.
       **/
      forceChangeAuthorities: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
      /**
       * Force removes an authority from keygen jail.
       *
       * Can only be called by the root origin.
       *
       * * `origin` - The account origin.
       * * `authority` - The authority to be removed from the keygen jail.
       **/
      forceUnjailKeygen: AugmentedSubmittable<
        (authority: DkgRuntimePrimitivesCryptoPublic | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [DkgRuntimePrimitivesCryptoPublic]
      >;
      /**
       * Force removes an authority from signing jail.
       *
       * Can only be called by the root origin.
       *
       * * `origin` - The account origin.
       * * `authority` - The authority to be removed from the signing jail.
       **/
      forceUnjailSigning: AugmentedSubmittable<
        (authority: DkgRuntimePrimitivesCryptoPublic | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [DkgRuntimePrimitivesCryptoPublic]
      >;
      /**
       * Manually Update the `RefreshNonce` (increment it by one).
       *
       * Can only be called by the root origin.
       *
       * * `origin` - The account origin.
       * **Important**: This function is only available for testing purposes.
       **/
      manualIncrementNonce: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
      /**
       * Manual Trigger DKG Refresh process.
       *
       * Can only be called by the root origin.
       *
       * * `origin` - The account that is initiating the refresh process.
       * **Important**: This function is only available for testing purposes.
       **/
      manualRefresh: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
      /**
       * Set the pending keygen threshold for the session following the next session.
       *
       * We cannot assume that the next DKG has not already completed keygen.
       * After all, if we are in a new session the next DKG may have already completed.
       * Therefore, when we update the thresholds we are updating a threshold
       * that will become the next threshold after the next session update.
       *
       * * `origin` - The account origin.
       * * `new_threshold` - The new keygen threshold for the DKG.
       **/
      setKeygenThreshold: AugmentedSubmittable<
        (newThreshold: u16 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [u16]
      >;
      /**
       * Sets the delay when a unsigned `RefreshProposal` will be added to the unsigned
       * proposal queue.
       *
       * * `origin` - The account origin.
       * * `new_delay` - The percentage of elapsed session duration to wait before adding an
       * unsigned refresh proposal to the unsigned proposal queue.
       **/
      setRefreshDelay: AugmentedSubmittable<
        (newDelay: u8 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [u8]
      >;
      /**
       * Set the pending signature threshold for the session following the next session.
       *
       * We cannot assume that the next DKG has not already completed keygen.
       * After all, if we are in a new session the next DKG may have already completed.
       * Therefore, when we update the thresholds we are updating a threshold
       * that will become the next threshold after the next session update.
       *
       * * `origin` - The account origin.
       * * `new_threshold` - The new signature threshold for the DKG.
       **/
      setSignatureThreshold: AugmentedSubmittable<
        (newThreshold: u16 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [u16]
      >;
      /**
       * Submits misbehaviour reports on chain. Signatures of the offending authority are
       * verified against the current or next authorities depending on the type of misbehaviour.
       * - Keygen: Verifies against the next authorities, since they are doing keygen.
       * - Signing: Verifies against the current authorities, since they are doing signing.
       *
       * Verifies the reports against the respective thresholds and if enough reports are met
       * begins to jail and decrease the reputation of the offending authority.
       *
       * The misbehaviour reputation update is:
       * AUTHORITY_REPUTATION = DECAY_PERCENTAGE * AUTHORITY_REPUTATION
       *
       * If there are not enough unjailed keygen authorities to perform a keygen after the next
       * session, then we deduct the pending keygen threshold (and pending signing threshold)
       * accordingly.
       *
       * * `origin` - The account origin.
       * * `reports` - The aggregated misbehaviour reports containing signatures of an offending
       * authority
       **/
      submitMisbehaviourReports: AugmentedSubmittable<
        (
          reports:
            | DkgRuntimePrimitivesAggregatedMisbehaviourReports
            | { misbehaviourType?: any; roundId?: any; offender?: any; reporters?: any; signatures?: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [DkgRuntimePrimitivesAggregatedMisbehaviourReports]
      >;
      /**
       * Submits and stores the next public key for the next session into the on-chain storage.
       *
       * Can only be submitted by the next authorities. It is also required that a
       * `NextSignatureThreshold` of submissions is reached in order to successfully
       * store the public key on-chain.
       *
       * * `origin` - The account origin.
       * * `keys_and_signatures` - The aggregated public keys and signatures for possible next
       * DKG public keys.
       **/
      submitNextPublicKey: AugmentedSubmittable<
        (
          keysAndSignatures:
            | DkgRuntimePrimitivesAggregatedPublicKeys
            | { keysAndSignatures?: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [DkgRuntimePrimitivesAggregatedPublicKeys]
      >;
      /**
       * Submits and stores the active public key for the genesis session into the on-chain
       * storage. This is primarily used to separate the genesis public key submission from
       * non-genesis rounds.
       *
       * Can only be submitted by the current authorities. It is also required that a
       * `SignatureThreshold` of submissions is reached in order to successfully
       * store the public key on-chain.
       *
       * * `origin` - The account origin.
       * * `keys_and_signatures` - The aggregated public keys and signatures for possible current
       * DKG public keys.
       **/
      submitPublicKey: AugmentedSubmittable<
        (
          keysAndSignatures:
            | DkgRuntimePrimitivesAggregatedPublicKeys
            | { keysAndSignatures?: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [DkgRuntimePrimitivesAggregatedPublicKeys]
      >;
      /**
       * Submits the public key signature for the key refresh/rotation process.
       *
       * The signature is the signature of the next public key `RefreshProposal`, signed by the
       * current DKG. It is stored on-chain only if it verifies successfully against the current
       * DKG's public key. Successful storage of this public key signature also removes
       * the unsigned `RefreshProposal` from the unsigned queue.
       *
       * For manual refreshes, after the signature is submitted and stored on-chain,
       * the keys are immediately refreshed and the authority set is immediately rotated
       * and incremented.
       *
       * * `origin` - The account origin.
       * * `signature_proposal` - The signed refresh proposal containing the public key signature
       * and nonce.
       **/
      submitPublicKeySignature: AugmentedSubmittable<
        (
          signatureProposal:
            | DkgRuntimePrimitivesProposalRefreshProposalSigned
            | { nonce?: any; signature?: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [DkgRuntimePrimitivesProposalRefreshProposalSigned]
      >;
      /**
       * Attempts to remove an authority from all possible jails (keygen & signing).
       * This can only be called by the controller of the authority in jail. The
       * origin must map directly to the authority in jail.
       *
       * The authority's jail sentence for either keygen or signing must be elapsed
       * for the authority to be removed from the jail.
       *
       * * `origin` - The account origin.
       **/
      unjail: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    dkgProposalHandler: {
      /**
       * Force submit an unsigned proposal to the DKG
       *
       * There are certain proposals we'd like to be proposable only
       * through root actions. The currently supported proposals are
       * 1. Updating
       **/
      forceSubmitUnsignedProposal: AugmentedSubmittable<
        (
          prop: DkgRuntimePrimitivesProposal | { Signed: any } | { Unsigned: any } | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [DkgRuntimePrimitivesProposal]
      >;
      submitSignedProposals: AugmentedSubmittable<
        (
          props:
            | Vec<DkgRuntimePrimitivesProposal>
            | (DkgRuntimePrimitivesProposal | { Signed: any } | { Unsigned: any } | string | Uint8Array)[]
        ) => SubmittableExtrinsic<ApiType>,
        [Vec<DkgRuntimePrimitivesProposal>]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    dkgProposals: {
      /**
       * Commits a vote in favour of the provided proposal.
       *
       * If a proposal with the given nonce and source chain ID does not
       * already exist, it will be created with an initial vote in favour
       * from the caller.
       *
       * # <weight>
       * - weight of proposed call, regardless of whether execution is performed
       * # </weight>
       **/
      acknowledgeProposal: AugmentedSubmittable<
        (
          nonce: u32 | AnyNumber | Uint8Array,
          srcChainId:
            | WebbProposalsHeaderTypedChainId
            | { None: any }
            | { Evm: any }
            | { Substrate: any }
            | { PolkadotParachain: any }
            | { KusamaParachain: any }
            | { RococoParachain: any }
            | { Cosmos: any }
            | { Solana: any }
            | string
            | Uint8Array,
          rId: WebbProposalsHeaderResourceId | string | Uint8Array,
          prop: Bytes | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, WebbProposalsHeaderTypedChainId, WebbProposalsHeaderResourceId, Bytes]
      >;
      /**
       * Adds a new proposer to the proposer set.
       *
       * # <weight>
       * - O(1) lookup and insert
       * # </weight>
       **/
      addProposer: AugmentedSubmittable<
        (
          nativeAccount: AccountId32 | string | Uint8Array,
          externalAccount: Bytes | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [AccountId32, Bytes]
      >;
      /**
       * Evaluate the state of a proposal given the current vote threshold.
       *
       * A proposal with enough votes will be either executed or cancelled,
       * and the status will be updated accordingly.
       *
       * # <weight>
       * - weight of proposed call, regardless of whether execution is performed
       * # </weight>
       **/
      evalVoteState: AugmentedSubmittable<
        (
          nonce: u32 | AnyNumber | Uint8Array,
          srcChainId:
            | WebbProposalsHeaderTypedChainId
            | { None: any }
            | { Evm: any }
            | { Substrate: any }
            | { PolkadotParachain: any }
            | { KusamaParachain: any }
            | { RococoParachain: any }
            | { Cosmos: any }
            | { Solana: any }
            | string
            | Uint8Array,
          prop: Bytes | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, WebbProposalsHeaderTypedChainId, Bytes]
      >;
      /**
       * Commits a vote against a provided proposal.
       *
       * # <weight>
       * - Fixed, since execution of proposal should not be included
       * # </weight>
       **/
      rejectProposal: AugmentedSubmittable<
        (
          nonce: u32 | AnyNumber | Uint8Array,
          srcChainId:
            | WebbProposalsHeaderTypedChainId
            | { None: any }
            | { Evm: any }
            | { Substrate: any }
            | { PolkadotParachain: any }
            | { KusamaParachain: any }
            | { RococoParachain: any }
            | { Cosmos: any }
            | { Solana: any }
            | string
            | Uint8Array,
          rId: WebbProposalsHeaderResourceId | string | Uint8Array,
          prop: Bytes | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, WebbProposalsHeaderTypedChainId, WebbProposalsHeaderResourceId, Bytes]
      >;
      /**
       * Removes an existing proposer from the set.
       *
       * # <weight>
       * - O(1) lookup and removal
       * # </weight>
       **/
      removeProposer: AugmentedSubmittable<
        (v: AccountId32 | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [AccountId32]
      >;
      /**
       * Removes a resource ID from the resource mapping.
       *
       * After this call, bridge transfers with the associated resource ID
       * will be rejected.
       *
       * # <weight>
       * - O(1) removal
       * # </weight>
       **/
      removeResource: AugmentedSubmittable<
        (id: WebbProposalsHeaderResourceId | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [WebbProposalsHeaderResourceId]
      >;
      /**
       * Stores a method name on chain under an associated resource ID.
       *
       * # <weight>
       * - O(1) write
       * # </weight>
       **/
      setResource: AugmentedSubmittable<
        (
          id: WebbProposalsHeaderResourceId | string | Uint8Array,
          method: Bytes | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [WebbProposalsHeaderResourceId, Bytes]
      >;
      /**
       * Sets the vote threshold for proposals.
       *
       * This threshold is used to determine how many votes are required
       * before a proposal is executed.
       *
       * # <weight>
       * - O(1) lookup and insert
       * # </weight>
       **/
      setThreshold: AugmentedSubmittable<
        (threshold: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [u32]
      >;
      /**
       * Enables a chain ID as a source or destination for a bridge transfer.
       *
       * # <weight>
       * - O(1) lookup and insert
       * # </weight>
       **/
      whitelistChain: AugmentedSubmittable<
        (
          chainId:
            | WebbProposalsHeaderTypedChainId
            | { None: any }
            | { Evm: any }
            | { Substrate: any }
            | { PolkadotParachain: any }
            | { KusamaParachain: any }
            | { RococoParachain: any }
            | { Cosmos: any }
            | { Solana: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [WebbProposalsHeaderTypedChainId]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    electionProviderMultiPhase: {
      /**
       * Trigger the governance fallback.
       *
       * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
       * calling [`Call::set_emergency_election_result`].
       **/
      governanceFallback: AugmentedSubmittable<
        (
          maybeMaxVoters: Option<u32> | null | object | string | Uint8Array,
          maybeMaxTargets: Option<u32> | null | object | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Option<u32>, Option<u32>]
      >;
      /**
       * Set a solution in the queue, to be handed out to the client of this pallet in the next
       * call to `ElectionProvider::elect`.
       *
       * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
       *
       * The solution is not checked for any feasibility and is assumed to be trustworthy, as any
       * feasibility check itself can in principle cause the election process to fail (due to
       * memory/weight constrains).
       **/
      setEmergencyElectionResult: AugmentedSubmittable<
        (
          supports:
            | Vec<ITuple<[AccountId32, SpNposElectionsSupport]>>
            | [
                AccountId32 | string | Uint8Array,
                SpNposElectionsSupport | { total?: any; voters?: any } | string | Uint8Array
              ][]
        ) => SubmittableExtrinsic<ApiType>,
        [Vec<ITuple<[AccountId32, SpNposElectionsSupport]>>]
      >;
      /**
       * Set a new value for `MinimumUntrustedScore`.
       *
       * Dispatch origin must be aligned with `T::ForceOrigin`.
       *
       * This check can be turned off by setting the value to `None`.
       **/
      setMinimumUntrustedScore: AugmentedSubmittable<
        (maybeNextScore: Option<Vec<u128>> | null | object | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Option<Vec<u128>>]
      >;
      /**
       * Submit a solution for the signed phase.
       *
       * The dispatch origin fo this call must be __signed__.
       *
       * The solution is potentially queued, based on the claimed score and processed at the end
       * of the signed phase.
       *
       * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
       * might be rewarded, slashed, or get all or a part of the deposit back.
       *
       * # <weight>
       * Queue size must be provided as witness data.
       * # </weight>
       **/
      submit: AugmentedSubmittable<
        (
          rawSolution:
            | PalletElectionProviderMultiPhaseRawSolution
            | { solution?: any; score?: any; round?: any }
            | string
            | Uint8Array,
          numSignedSubmissions: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [PalletElectionProviderMultiPhaseRawSolution, u32]
      >;
      /**
       * Submit a solution for the unsigned phase.
       *
       * The dispatch origin fo this call must be __none__.
       *
       * This submission is checked on the fly. Moreover, this unsigned solution is only
       * validated when submitted to the pool from the **local** node. Effectively, this means
       * that only active validators can submit this transaction when authoring a block (similar
       * to an inherent).
       *
       * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
       * panic if the solution submitted by the validator is invalid in any way, effectively
       * putting their authoring reward at risk.
       *
       * No deposit or reward is associated with this submission.
       **/
      submitUnsigned: AugmentedSubmittable<
        (
          rawSolution:
            | PalletElectionProviderMultiPhaseRawSolution
            | { solution?: any; score?: any; round?: any }
            | string
            | Uint8Array,
          witness:
            | PalletElectionProviderMultiPhaseSolutionOrSnapshotSize
            | { voters?: any; targets?: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [PalletElectionProviderMultiPhaseRawSolution, PalletElectionProviderMultiPhaseSolutionOrSnapshotSize]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    elections: {
      /**
       * Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
       * deposit of the removed voters are returned.
       *
       * This is an root function to be used only for cleaning the state.
       *
       * The dispatch origin of this call must be root.
       *
       * # <weight>
       * The total number of voters and those that are defunct must be provided as witness data.
       * # </weight>
       **/
      cleanDefunctVoters: AugmentedSubmittable<
        (
          numVoters: u32 | AnyNumber | Uint8Array,
          numDefunct: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, u32]
      >;
      /**
       * Remove a particular member from the set. This is effective immediately and the bond of
       * the outgoing member is slashed.
       *
       * If a runner-up is available, then the best runner-up will be removed and replaces the
       * outgoing member. Otherwise, a new phragmen election is started.
       *
       * The dispatch origin of this call must be root.
       *
       * Note that this does not affect the designated block number of the next election.
       *
       * # <weight>
       * If we have a replacement, we use a small weight. Else, since this is a root call and
       * will go into phragmen, we assume full block for now.
       * # </weight>
       **/
      removeMember: AugmentedSubmittable<
        (
          who:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          hasReplacement: bool | boolean | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, bool]
      >;
      /**
       * Remove `origin` as a voter.
       *
       * This removes the lock and returns the deposit.
       *
       * The dispatch origin of this call must be signed and be a voter.
       **/
      removeVoter: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
      /**
       * Renounce one's intention to be a candidate for the next election round. 3 potential
       * outcomes exist:
       *
       * - `origin` is a candidate and not elected in any set. In this case, the deposit is
       * unreserved, returned and origin is removed as a candidate.
       * - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
       * origin is removed as a runner-up.
       * - `origin` is a current member. In this case, the deposit is unreserved and origin is
       * removed as a member, consequently not being a candidate for the next round anymore.
       * Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they
       * are immediately used. If the prime is renouncing, then no prime will exist until the
       * next round.
       *
       * The dispatch origin of this call must be signed, and have one of the above roles.
       *
       * # <weight>
       * The type of renouncing must be provided as witness data.
       * # </weight>
       **/
      renounceCandidacy: AugmentedSubmittable<
        (
          renouncing:
            | PalletElectionsPhragmenRenouncing
            | { Member: any }
            | { RunnerUp: any }
            | { Candidate: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [PalletElectionsPhragmenRenouncing]
      >;
      /**
       * Submit oneself for candidacy. A fixed amount of deposit is recorded.
       *
       * All candidates are wiped at the end of the term. They either become a member/runner-up,
       * or leave the system while their deposit is slashed.
       *
       * The dispatch origin of this call must be signed.
       *
       * ### Warning
       *
       * Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
       * to get their deposit back. Losing the spot in an election will always lead to a slash.
       *
       * # <weight>
       * The number of current candidates must be provided as witness data.
       * # </weight>
       **/
      submitCandidacy: AugmentedSubmittable<
        (candidateCount: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>]
      >;
      /**
       * Vote for a set of candidates for the upcoming round of election. This can be called to
       * set the initial votes, or update already existing votes.
       *
       * Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
       * reserved. The deposit is based on the number of votes and can be updated over time.
       *
       * The `votes` should:
       * - not be empty.
       * - be less than the number of possible candidates. Note that all current members and
       * runners-up are also automatically candidates for the next round.
       *
       * If `value` is more than `who`'s free balance, then the maximum of the two is used.
       *
       * The dispatch origin of this call must be signed.
       *
       * ### Warning
       *
       * It is the responsibility of the caller to **NOT** place all of their balance into the
       * lock and keep some for further operations.
       *
       * # <weight>
       * We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less.
       * # </weight>
       **/
      vote: AugmentedSubmittable<
        (
          votes: Vec<AccountId32> | (AccountId32 | string | Uint8Array)[],
          value: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Vec<AccountId32>, Compact<u128>]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    grandpa: {
      /**
       * Note that the current authority set of the GRANDPA finality gadget has
       * stalled. This will trigger a forced authority set change at the beginning
       * of the next session, to be enacted `delay` blocks after that. The delay
       * should be high enough to safely assume that the block signalling the
       * forced change will not be re-orged (e.g. 1000 blocks). The GRANDPA voters
       * will start the new authority set using the given finalized block as base.
       * Only callable by root.
       **/
      noteStalled: AugmentedSubmittable<
        (
          delay: u32 | AnyNumber | Uint8Array,
          bestFinalizedBlockNumber: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, u32]
      >;
      /**
       * Report voter equivocation/misbehavior. This method will verify the
       * equivocation proof and validate the given key ownership proof
       * against the extracted offender. If both are valid, the offence
       * will be reported.
       **/
      reportEquivocation: AugmentedSubmittable<
        (
          equivocationProof:
            | SpFinalityGrandpaEquivocationProof
            | { setId?: any; equivocation?: any }
            | string
            | Uint8Array,
          keyOwnerProof:
            | SpSessionMembershipProof
            | { session?: any; trieNodes?: any; validatorCount?: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [SpFinalityGrandpaEquivocationProof, SpSessionMembershipProof]
      >;
      /**
       * Report voter equivocation/misbehavior. This method will verify the
       * equivocation proof and validate the given key ownership proof
       * against the extracted offender. If both are valid, the offence
       * will be reported.
       *
       * This extrinsic must be called unsigned and it is expected that only
       * block authors will call it (validated in `ValidateUnsigned`), as such
       * if the block author is defined it will be defined as the equivocation
       * reporter.
       **/
      reportEquivocationUnsigned: AugmentedSubmittable<
        (
          equivocationProof:
            | SpFinalityGrandpaEquivocationProof
            | { setId?: any; equivocation?: any }
            | string
            | Uint8Array,
          keyOwnerProof:
            | SpSessionMembershipProof
            | { session?: any; trieNodes?: any; validatorCount?: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [SpFinalityGrandpaEquivocationProof, SpSessionMembershipProof]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    hasherBn254: {
      forceSetParameters: AugmentedSubmittable<
        (parameters: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    linkableTreeBn254: {
      create: AugmentedSubmittable<
        (maxEdges: u32 | AnyNumber | Uint8Array, depth: u8 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [u32, u8]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    merkleTreeBn254: {
      create: AugmentedSubmittable<(depth: u8 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u8]>;
      forceSetDefaultHashes: AugmentedSubmittable<
        (
          defaultHashes:
            | Vec<EggStandaloneRuntimeProtocolSubstrateConfigElement>
            | (EggStandaloneRuntimeProtocolSubstrateConfigElement | string | Uint8Array)[]
        ) => SubmittableExtrinsic<ApiType>,
        [Vec<EggStandaloneRuntimeProtocolSubstrateConfigElement>]
      >;
      insert: AugmentedSubmittable<
        (
          treeId: u32 | AnyNumber | Uint8Array,
          leaf: EggStandaloneRuntimeProtocolSubstrateConfigElement | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, EggStandaloneRuntimeProtocolSubstrateConfigElement]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    mixerBn254: {
      create: AugmentedSubmittable<
        (
          depositSize: u128 | AnyNumber | Uint8Array,
          depth: u8 | AnyNumber | Uint8Array,
          asset: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u128, u8, u32]
      >;
      deposit: AugmentedSubmittable<
        (
          treeId: u32 | AnyNumber | Uint8Array,
          leaf: EggStandaloneRuntimeProtocolSubstrateConfigElement | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, EggStandaloneRuntimeProtocolSubstrateConfigElement]
      >;
      withdraw: AugmentedSubmittable<
        (
          id: u32 | AnyNumber | Uint8Array,
          proofBytes: Bytes | string | Uint8Array,
          root: EggStandaloneRuntimeProtocolSubstrateConfigElement | string | Uint8Array,
          nullifierHash: EggStandaloneRuntimeProtocolSubstrateConfigElement | string | Uint8Array,
          recipient: AccountId32 | string | Uint8Array,
          relayer: AccountId32 | string | Uint8Array,
          fee: u128 | AnyNumber | Uint8Array,
          refund: u128 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [
          u32,
          Bytes,
          EggStandaloneRuntimeProtocolSubstrateConfigElement,
          EggStandaloneRuntimeProtocolSubstrateConfigElement,
          AccountId32,
          AccountId32,
          u128,
          u128
        ]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    mixerVerifierBn254: {
      forceSetParameters: AugmentedSubmittable<
        (parameters: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    preimage: {
      /**
       * Register a preimage on-chain.
       *
       * If the preimage was previously requested, no fees or deposits are taken for providing
       * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
       **/
      notePreimage: AugmentedSubmittable<
        (bytes: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes]
      >;
      /**
       * Request a preimage be uploaded to the chain without paying any fees or deposits.
       *
       * If the preimage requests has already been provided on-chain, we unreserve any deposit
       * a user may have paid, and take the control of the preimage out of their hands.
       **/
      requestPreimage: AugmentedSubmittable<
        (hash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [H256]
      >;
      /**
       * Clear an unrequested preimage from the runtime storage.
       **/
      unnotePreimage: AugmentedSubmittable<(hash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H256]>;
      /**
       * Clear a previously made request for a preimage.
       *
       * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
       **/
      unrequestPreimage: AugmentedSubmittable<
        (hash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [H256]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    scheduler: {
      /**
       * Cancel an anonymously scheduled task.
       **/
      cancel: AugmentedSubmittable<
        (when: u32 | AnyNumber | Uint8Array, index: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [u32, u32]
      >;
      /**
       * Cancel a named scheduled task.
       **/
      cancelNamed: AugmentedSubmittable<(id: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;
      /**
       * Anonymously schedule a task.
       **/
      schedule: AugmentedSubmittable<
        (
          when: u32 | AnyNumber | Uint8Array,
          maybePeriodic: Option<ITuple<[u32, u32]>> | null | object | string | Uint8Array,
          priority: u8 | AnyNumber | Uint8Array,
          call: FrameSupportScheduleMaybeHashed | { Value: any } | { Hash: any } | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, Option<ITuple<[u32, u32]>>, u8, FrameSupportScheduleMaybeHashed]
      >;
      /**
       * Anonymously schedule a task after a delay.
       *
       * # <weight>
       * Same as [`schedule`].
       * # </weight>
       **/
      scheduleAfter: AugmentedSubmittable<
        (
          after: u32 | AnyNumber | Uint8Array,
          maybePeriodic: Option<ITuple<[u32, u32]>> | null | object | string | Uint8Array,
          priority: u8 | AnyNumber | Uint8Array,
          call: FrameSupportScheduleMaybeHashed | { Value: any } | { Hash: any } | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, Option<ITuple<[u32, u32]>>, u8, FrameSupportScheduleMaybeHashed]
      >;
      /**
       * Schedule a named task.
       **/
      scheduleNamed: AugmentedSubmittable<
        (
          id: Bytes | string | Uint8Array,
          when: u32 | AnyNumber | Uint8Array,
          maybePeriodic: Option<ITuple<[u32, u32]>> | null | object | string | Uint8Array,
          priority: u8 | AnyNumber | Uint8Array,
          call: FrameSupportScheduleMaybeHashed | { Value: any } | { Hash: any } | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Bytes, u32, Option<ITuple<[u32, u32]>>, u8, FrameSupportScheduleMaybeHashed]
      >;
      /**
       * Schedule a named task after a delay.
       *
       * # <weight>
       * Same as [`schedule_named`](Self::schedule_named).
       * # </weight>
       **/
      scheduleNamedAfter: AugmentedSubmittable<
        (
          id: Bytes | string | Uint8Array,
          after: u32 | AnyNumber | Uint8Array,
          maybePeriodic: Option<ITuple<[u32, u32]>> | null | object | string | Uint8Array,
          priority: u8 | AnyNumber | Uint8Array,
          call: FrameSupportScheduleMaybeHashed | { Value: any } | { Hash: any } | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Bytes, u32, Option<ITuple<[u32, u32]>>, u8, FrameSupportScheduleMaybeHashed]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    session: {
      /**
       * Removes any session key(s) of the function caller.
       *
       * This doesn't take effect until the next session.
       *
       * The dispatch origin of this function must be Signed and the account must be either be
       * convertible to a validator ID using the chain's typical addressing system (this usually
       * means being a controller account) or directly convertible into a validator ID (which
       * usually means being a stash account).
       *
       * # <weight>
       * - Complexity: `O(1)` in number of key types. Actual cost depends on the number of length
       * of `T::Keys::key_ids()` which is fixed.
       * - DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`
       * - DbWrites: `NextKeys`, `origin account`
       * - DbWrites per key id: `KeyOwner`
       * # </weight>
       **/
      purgeKeys: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
      /**
       * Sets the session key(s) of the function caller to `keys`.
       * Allows an account to set its session key prior to becoming a validator.
       * This doesn't take effect until the next session.
       *
       * The dispatch origin of this function must be signed.
       *
       * # <weight>
       * - Complexity: `O(1)`. Actual cost depends on the number of length of
       * `T::Keys::key_ids()` which is fixed.
       * - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
       * - DbWrites: `origin account`, `NextKeys`
       * - DbReads per key id: `KeyOwner`
       * - DbWrites per key id: `KeyOwner`
       * # </weight>
       **/
      setKeys: AugmentedSubmittable<
        (
          keys: EggStandaloneRuntimeOpaqueSessionKeys | { aura?: any; grandpa?: any; dkg?: any } | string | Uint8Array,
          proof: Bytes | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [EggStandaloneRuntimeOpaqueSessionKeys, Bytes]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    staking: {
      /**
       * Take the origin account as a stash and lock up `value` of its balance. `controller` will
       * be the account that controls it.
       *
       * `value` must be more than the `minimum_balance` specified by `T::Currency`.
       *
       * The dispatch origin for this call must be _Signed_ by the stash account.
       *
       * Emits `Bonded`.
       * # <weight>
       * - Independent of the arguments. Moderate complexity.
       * - O(1).
       * - Three extra DB entries.
       *
       * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
       * unless the `origin` falls below _existential deposit_ and gets removed as dust.
       * ------------------
       * # </weight>
       **/
      bond: AugmentedSubmittable<
        (
          controller:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          value: Compact<u128> | AnyNumber | Uint8Array,
          payee:
            | PalletStakingRewardDestination
            | { Staked: any }
            | { Stash: any }
            | { Controller: any }
            | { Account: any }
            | { None: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, Compact<u128>, PalletStakingRewardDestination]
      >;
      /**
       * Add some extra amount that have appeared in the stash `free_balance` into the balance up
       * for staking.
       *
       * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
       *
       * Use this if there are additional funds in your stash account that you wish to bond.
       * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
       * any limitation on the amount that can be added.
       *
       * Emits `Bonded`.
       *
       * # <weight>
       * - Independent of the arguments. Insignificant complexity.
       * - O(1).
       * # </weight>
       **/
      bondExtra: AugmentedSubmittable<
        (maxAdditional: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u128>]
      >;
      /**
       * Cancel enactment of a deferred slash.
       *
       * Can be called by the `T::SlashCancelOrigin`.
       *
       * Parameters: era and indices of the slashes for that era to kill.
       **/
      cancelDeferredSlash: AugmentedSubmittable<
        (
          era: u32 | AnyNumber | Uint8Array,
          slashIndices: Vec<u32> | (u32 | AnyNumber | Uint8Array)[]
        ) => SubmittableExtrinsic<ApiType>,
        [u32, Vec<u32>]
      >;
      /**
       * Declare no desire to either validate or nominate.
       *
       * Effects will be felt at the beginning of the next era.
       *
       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
       *
       * # <weight>
       * - Independent of the arguments. Insignificant complexity.
       * - Contains one read.
       * - Writes are limited to the `origin` account key.
       * # </weight>
       **/
      chill: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
      /**
       * Declare a `controller` to stop participating as either a validator or nominator.
       *
       * Effects will be felt at the beginning of the next era.
       *
       * The dispatch origin for this call must be _Signed_, but can be called by anyone.
       *
       * If the caller is the same as the controller being targeted, then no further checks are
       * enforced, and this function behaves just like `chill`.
       *
       * If the caller is different than the controller being targeted, the following conditions
       * must be met:
       *
       * * `controller` must belong to a nominator who has become non-decodable,
       *
       * Or:
       *
       * * A `ChillThreshold` must be set and checked which defines how close to the max
       * nominators or validators we must reach before users can start chilling one-another.
       * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
       * how close we are to the threshold.
       * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
       * if this is a person that should be chilled because they have not met the threshold
       * bond required.
       *
       * This can be helpful if bond requirements are updated, and we need to remove old users
       * who do not satisfy these requirements.
       **/
      chillOther: AugmentedSubmittable<
        (controller: AccountId32 | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [AccountId32]
      >;
      /**
       * Force a validator to have at least the minimum commission. This will not affect a
       * validator who already has a commission greater than or equal to the minimum. Any account
       * can call this.
       **/
      forceApplyMinCommission: AugmentedSubmittable<
        (validatorStash: AccountId32 | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [AccountId32]
      >;
      /**
       * Force there to be a new era at the end of the next session. After this, it will be
       * reset to normal (non-forced) behaviour.
       *
       * The dispatch origin must be Root.
       *
       * # Warning
       *
       * The election process starts multiple blocks before the end of the era.
       * If this is called just before a new era is triggered, the election process may not
       * have enough blocks to get a result.
       *
       * # <weight>
       * - No arguments.
       * - Weight: O(1)
       * - Write ForceEra
       * # </weight>
       **/
      forceNewEra: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
      /**
       * Force there to be a new era at the end of sessions indefinitely.
       *
       * The dispatch origin must be Root.
       *
       * # Warning
       *
       * The election process starts multiple blocks before the end of the era.
       * If this is called just before a new era is triggered, the election process may not
       * have enough blocks to get a result.
       **/
      forceNewEraAlways: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
      /**
       * Force there to be no new eras indefinitely.
       *
       * The dispatch origin must be Root.
       *
       * # Warning
       *
       * The election process starts multiple blocks before the end of the era.
       * Thus the election process may be ongoing when this is called. In this case the
       * election will continue until the next era is triggered.
       *
       * # <weight>
       * - No arguments.
       * - Weight: O(1)
       * - Write: ForceEra
       * # </weight>
       **/
      forceNoEras: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;
      /**
       * Force a current staker to become completely unstaked, immediately.
       *
       * The dispatch origin must be Root.
       **/
      forceUnstake: AugmentedSubmittable<
        (
          stash: AccountId32 | string | Uint8Array,
          numSlashingSpans: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [AccountId32, u32]
      >;
      /**
       * Increments the ideal number of validators.
       *
       * The dispatch origin must be Root.
       *
       * # <weight>
       * Same as [`Self::set_validator_count`].
       * # </weight>
       **/
      increaseValidatorCount: AugmentedSubmittable<
        (additional: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>]
      >;
      /**
       * Remove the given nominations from the calling validator.
       *
       * Effects will be felt at the beginning of the next era.
       *
       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
       *
       * - `who`: A list of nominator stash accounts who are nominating this validator which
       * should no longer be nominating this validator.
       *
       * Note: Making this call only makes sense if you first set the validator preferences to
       * block any further nominations.
       **/
      kick: AugmentedSubmittable<
        (
          who:
            | Vec<MultiAddress>
            | (
                | MultiAddress
                | { Id: any }
                | { Index: any }
                | { Raw: any }
                | { Address32: any }
                | { Address20: any }
                | string
                | Uint8Array
              )[]
        ) => SubmittableExtrinsic<ApiType>,
        [Vec<MultiAddress>]
      >;
      /**
       * Declare the desire to nominate `targets` for the origin controller.
       *
       * Effects will be felt at the beginning of the next era.
       *
       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
       *
       * # <weight>
       * - The transaction's complexity is proportional to the size of `targets` (N)
       * which is capped at CompactAssignments::LIMIT (T::MaxNominations).
       * - Both the reads and writes follow a similar pattern.
       * # </weight>
       **/
      nominate: AugmentedSubmittable<
        (
          targets:
            | Vec<MultiAddress>
            | (
                | MultiAddress
                | { Id: any }
                | { Index: any }
                | { Raw: any }
                | { Address32: any }
                | { Address20: any }
                | string
                | Uint8Array
              )[]
        ) => SubmittableExtrinsic<ApiType>,
        [Vec<MultiAddress>]
      >;
      /**
       * Pay out all the stakers behind a single validator for a single era.
       *
       * - `validator_stash` is the stash account of the validator. Their nominators, up to
       * `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.
       * - `era` may be any era between `[current_era - history_depth; current_era]`.
       *
       * The origin of this call must be _Signed_. Any account can call this function, even if
       * it is not one of the stakers.
       *
       * # <weight>
       * - Time complexity: at most O(MaxNominatorRewardedPerValidator).
       * - Contains a limited number of reads and writes.
       * -----------
       * N is the Number of payouts for the validator (including the validator)
       * Weight:
       * - Reward Destination Staked: O(N)
       * - Reward Destination Controller (Creating): O(N)
       *
       * NOTE: weights are assuming that payouts are made to alive stash account (Staked).
       * Paying even a dead controller is cheaper weight-wise. We don't do any refunds here.
       * # </weight>
       **/
      payoutStakers: AugmentedSubmittable<
        (
          validatorStash: AccountId32 | string | Uint8Array,
          era: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [AccountId32, u32]
      >;
      /**
       * Remove all data structures concerning a staker/stash once it is at a state where it can
       * be considered `dust` in the staking system. The requirements are:
       *
       * 1. the `total_balance` of the stash is below existential deposit.
       * 2. or, the `ledger.total` of the stash is below existential deposit.
       *
       * The former can happen in cases like a slash; the latter when a fully unbonded account
       * is still receiving staking rewards in `RewardDestination::Staked`.
       *
       * It can be called by anyone, as long as `stash` meets the above requirements.
       *
       * Refunds the transaction fees upon successful execution.
       **/
      reapStash: AugmentedSubmittable<
        (
          stash: AccountId32 | string | Uint8Array,
          numSlashingSpans: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [AccountId32, u32]
      >;
      /**
       * Rebond a portion of the stash scheduled to be unlocked.
       *
       * The dispatch origin must be signed by the controller.
       *
       * # <weight>
       * - Time complexity: O(L), where L is unlocking chunks
       * - Bounded by `MAX_UNLOCKING_CHUNKS`.
       * - Storage changes: Can't increase storage, only decrease it.
       * # </weight>
       **/
      rebond: AugmentedSubmittable<
        (value: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u128>]
      >;
      /**
       * Scale up the ideal number of validators by a factor.
       *
       * The dispatch origin must be Root.
       *
       * # <weight>
       * Same as [`Self::set_validator_count`].
       * # </weight>
       **/
      scaleValidatorCount: AugmentedSubmittable<
        (factor: Percent | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Percent]
      >;
      /**
       * (Re-)set the controller of a stash.
       *
       * Effects will be felt at the beginning of the next era.
       *
       * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
       *
       * # <weight>
       * - Independent of the arguments. Insignificant complexity.
       * - Contains a limited number of reads.
       * - Writes are limited to the `origin` account key.
       * ----------
       * Weight: O(1)
       * DB Weight:
       * - Read: Bonded, Ledger New Controller, Ledger Old Controller
       * - Write: Bonded, Ledger New Controller, Ledger Old Controller
       * # </weight>
       **/
      setController: AugmentedSubmittable<
        (
          controller:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress]
      >;
      /**
       * Set `HistoryDepth` value. This function will delete any history information
       * when `HistoryDepth` is reduced.
       *
       * Parameters:
       * - `new_history_depth`: The new history depth you would like to set.
       * - `era_items_deleted`: The number of items that will be deleted by this dispatch. This
       * should report all the storage items that will be deleted by clearing old era history.
       * Needed to report an accurate weight for the dispatch. Trusted by `Root` to report an
       * accurate number.
       *
       * Origin must be root.
       *
       * # <weight>
       * - E: Number of history depths removed, i.e. 10 -> 7 = 3
       * - Weight: O(E)
       * - DB Weight:
       * - Reads: Current Era, History Depth
       * - Writes: History Depth
       * - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs
       * - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake,
       * ErasStartSessionIndex
       * # </weight>
       **/
      setHistoryDepth: AugmentedSubmittable<
        (
          newHistoryDepth: Compact<u32> | AnyNumber | Uint8Array,
          eraItemsDeleted: Compact<u32> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>, Compact<u32>]
      >;
      /**
       * Set the validators who cannot be slashed (if any).
       *
       * The dispatch origin must be Root.
       **/
      setInvulnerables: AugmentedSubmittable<
        (invulnerables: Vec<AccountId32> | (AccountId32 | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>,
        [Vec<AccountId32>]
      >;
      /**
       * (Re-)set the payment target for a controller.
       *
       * Effects will be felt at the beginning of the next era.
       *
       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
       *
       * # <weight>
       * - Independent of the arguments. Insignificant complexity.
       * - Contains a limited number of reads.
       * - Writes are limited to the `origin` account key.
       * ---------
       * - Weight: O(1)
       * - DB Weight:
       * - Read: Ledger
       * - Write: Payee
       * # </weight>
       **/
      setPayee: AugmentedSubmittable<
        (
          payee:
            | PalletStakingRewardDestination
            | { Staked: any }
            | { Stash: any }
            | { Controller: any }
            | { Account: any }
            | { None: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [PalletStakingRewardDestination]
      >;
      /**
       * Update the various staking configurations .
       *
       * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
       * * `min_validator_bond`: The minimum active bond needed to be a validator.
       * * `max_nominator_count`: The max number of users who can be a nominator at once. When
       * set to `None`, no limit is enforced.
       * * `max_validator_count`: The max number of users who can be a validator at once. When
       * set to `None`, no limit is enforced.
       * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
       * should be filled in order for the `chill_other` transaction to work.
       * * `min_commission`: The minimum amount of commission that each validators must maintain.
       * This is checked only upon calling `validate`. Existing validators are not affected.
       *
       * Origin must be Root to call this function.
       *
       * NOTE: Existing nominators and validators will not be affected by this update.
       * to kick people under the new limits, `chill_other` should be called.
       **/
      setStakingConfigs: AugmentedSubmittable<
        (
          minNominatorBond: u128 | AnyNumber | Uint8Array,
          minValidatorBond: u128 | AnyNumber | Uint8Array,
          maxNominatorCount: Option<u32> | null | object | string | Uint8Array,
          maxValidatorCount: Option<u32> | null | object | string | Uint8Array,
          chillThreshold: Option<Percent> | null | object | string | Uint8Array,
          minCommission: Perbill | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u128, u128, Option<u32>, Option<u32>, Option<Percent>, Perbill]
      >;
      /**
       * Sets the ideal number of validators.
       *
       * The dispatch origin must be Root.
       *
       * # <weight>
       * Weight: O(1)
       * Write: Validator Count
       * # </weight>
       **/
      setValidatorCount: AugmentedSubmittable<
        (updated: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>]
      >;
      /**
       * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
       * period ends. If this leaves an amount actively bonded less than
       * T::Currency::minimum_balance(), then it is increased to the full amount.
       *
       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
       *
       * Once the unlock period is done, you can call `withdraw_unbonded` to actually move
       * the funds out of management ready for transfer.
       *
       * No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)
       * can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need
       * to be called first to remove some of the chunks (if possible).
       *
       * If a user encounters the `InsufficientBond` error when calling this extrinsic,
       * they should call `chill` first in order to free up their bonded funds.
       *
       * Emits `Unbonded`.
       *
       * See also [`Call::withdraw_unbonded`].
       **/
      unbond: AugmentedSubmittable<
        (value: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u128>]
      >;
      /**
       * Declare the desire to validate for the origin controller.
       *
       * Effects will be felt at the beginning of the next era.
       *
       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
       **/
      validate: AugmentedSubmittable<
        (
          prefs: PalletStakingValidatorPrefs | { commission?: any; blocked?: any } | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [PalletStakingValidatorPrefs]
      >;
      /**
       * Remove any unlocked chunks from the `unlocking` queue from our management.
       *
       * This essentially frees up that balance to be used by the stash account to do
       * whatever it wants.
       *
       * The dispatch origin for this call must be _Signed_ by the controller.
       *
       * Emits `Withdrawn`.
       *
       * See also [`Call::unbond`].
       *
       * # <weight>
       * Complexity O(S) where S is the number of slashing spans to remove
       * NOTE: Weight annotation is the kill scenario, we refund otherwise.
       * # </weight>
       **/
      withdrawUnbonded: AugmentedSubmittable<
        (numSlashingSpans: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [u32]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    sudo: {
      /**
       * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
       * key.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * # <weight>
       * - O(1).
       * - Limited storage reads.
       * - One DB change.
       * # </weight>
       **/
      setKey: AugmentedSubmittable<
        (
          updated:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress]
      >;
      /**
       * Authenticates the sudo key and dispatches a function call with `Root` origin.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * # <weight>
       * - O(1).
       * - Limited storage reads.
       * - One DB write (event).
       * - Weight of derivative `call` execution + 10,000.
       * # </weight>
       **/
      sudo: AugmentedSubmittable<
        (call: Call | { callIndex?: any; args?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Call]
      >;
      /**
       * Authenticates the sudo key and dispatches a function call with `Signed` origin from
       * a given account.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * # <weight>
       * - O(1).
       * - Limited storage reads.
       * - One DB write (event).
       * - Weight of derivative `call` execution + 10,000.
       * # </weight>
       **/
      sudoAs: AugmentedSubmittable<
        (
          who:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          call: Call | { callIndex?: any; args?: any } | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, Call]
      >;
      /**
       * Authenticates the sudo key and dispatches a function call with `Root` origin.
       * This function does not check the weight of the call, and instead allows the
       * Sudo user to specify the weight of the call.
       *
       * The dispatch origin for this call must be _Signed_.
       *
       * # <weight>
       * - O(1).
       * - The weight of this call is defined by the caller.
       * # </weight>
       **/
      sudoUncheckedWeight: AugmentedSubmittable<
        (
          call: Call | { callIndex?: any; args?: any } | string | Uint8Array,
          weight: u64 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Call, u64]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    system: {
      /**
       * A dispatch that will fill the block weight up to the given ratio.
       **/
      fillBlock: AugmentedSubmittable<
        (ratio: Perbill | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Perbill]
      >;
      /**
       * Kill all storage items with a key that starts with the given prefix.
       *
       * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
       * the prefix we are removing to accurately calculate the weight of this function.
       **/
      killPrefix: AugmentedSubmittable<
        (prefix: Bytes | string | Uint8Array, subkeys: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes, u32]
      >;
      /**
       * Kill some items from storage.
       **/
      killStorage: AugmentedSubmittable<
        (keys: Vec<Bytes> | (Bytes | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>,
        [Vec<Bytes>]
      >;
      /**
       * Make some on-chain remark.
       *
       * # <weight>
       * - `O(1)`
       * # </weight>
       **/
      remark: AugmentedSubmittable<(remark: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;
      /**
       * Make some on-chain remark and emit event.
       **/
      remarkWithEvent: AugmentedSubmittable<
        (remark: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes]
      >;
      /**
       * Set the new runtime code.
       *
       * # <weight>
       * - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`
       * - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is
       * expensive).
       * - 1 storage write (codec `O(C)`).
       * - 1 digest item.
       * - 1 event.
       * The weight of this function is dependent on the runtime, but generally this is very
       * expensive. We will treat this as a full block.
       * # </weight>
       **/
      setCode: AugmentedSubmittable<(code: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;
      /**
       * Set the new runtime code without doing any checks of the given `code`.
       *
       * # <weight>
       * - `O(C)` where `C` length of `code`
       * - 1 storage write (codec `O(C)`).
       * - 1 digest item.
       * - 1 event.
       * The weight of this function is dependent on the runtime. We will treat this as a full
       * block. # </weight>
       **/
      setCodeWithoutChecks: AugmentedSubmittable<
        (code: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes]
      >;
      /**
       * Set the number of pages in the WebAssembly environment's heap.
       **/
      setHeapPages: AugmentedSubmittable<(pages: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;
      /**
       * Set some items of storage.
       **/
      setStorage: AugmentedSubmittable<
        (
          items: Vec<ITuple<[Bytes, Bytes]>> | [Bytes | string | Uint8Array, Bytes | string | Uint8Array][]
        ) => SubmittableExtrinsic<ApiType>,
        [Vec<ITuple<[Bytes, Bytes]>>]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    timestamp: {
      /**
       * Set the current time.
       *
       * This call should be invoked exactly once per block. It will panic at the finalization
       * phase, if this call hasn't been invoked by that time.
       *
       * The timestamp should be greater than the previous one by the amount specified by
       * `MinimumPeriod`.
       *
       * The dispatch origin for this call must be `Inherent`.
       *
       * # <weight>
       * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
       * - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in
       * `on_finalize`)
       * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
       * # </weight>
       **/
      set: AugmentedSubmittable<
        (now: Compact<u64> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u64>]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    tokens: {
      /**
       * Exactly as `transfer`, except the origin must be root and the source
       * account may be specified.
       *
       * The dispatch origin for this call must be _Root_.
       *
       * - `source`: The sender of the transfer.
       * - `dest`: The recipient of the transfer.
       * - `currency_id`: currency type.
       * - `amount`: free balance amount to tranfer.
       **/
      forceTransfer: AugmentedSubmittable<
        (
          source:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          dest:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          currencyId: u32 | AnyNumber | Uint8Array,
          amount: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, MultiAddress, u32, Compact<u128>]
      >;
      /**
       * Set the balances of a given account.
       *
       * This will alter `FreeBalance` and `ReservedBalance` in storage. it
       * will also decrease the total issuance of the system
       * (`TotalIssuance`). If the new free or reserved balance is below the
       * existential deposit, it will reap the `AccountInfo`.
       *
       * The dispatch origin for this call is `root`.
       **/
      setBalance: AugmentedSubmittable<
        (
          who:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          currencyId: u32 | AnyNumber | Uint8Array,
          newFree: Compact<u128> | AnyNumber | Uint8Array,
          newReserved: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, u32, Compact<u128>, Compact<u128>]
      >;
      /**
       * Transfer some liquid free balance to another account.
       *
       * `transfer` will set the `FreeBalance` of the sender and receiver.
       * It will decrease the total issuance of the system by the
       * `TransferFee`. If the sender's account is below the existential
       * deposit as a result of the transfer, the account will be reaped.
       *
       * The dispatch origin for this call must be `Signed` by the
       * transactor.
       *
       * - `dest`: The recipient of the transfer.
       * - `currency_id`: currency type.
       * - `amount`: free balance amount to tranfer.
       **/
      transfer: AugmentedSubmittable<
        (
          dest:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          currencyId: u32 | AnyNumber | Uint8Array,
          amount: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, u32, Compact<u128>]
      >;
      /**
       * Transfer all remaining balance to the given account.
       *
       * NOTE: This function only attempts to transfer _transferable_
       * balances. This means that any locked, reserved, or existential
       * deposits (when `keep_alive` is `true`), will not be transferred by
       * this function. To ensure that this function results in a killed
       * account, you might need to prepare the account by removing any
       * reference counters, storage deposits, etc...
       *
       * The dispatch origin for this call must be `Signed` by the
       * transactor.
       *
       * - `dest`: The recipient of the transfer.
       * - `currency_id`: currency type.
       * - `keep_alive`: A boolean to determine if the `transfer_all`
       * operation should send all of the funds the account has, causing
       * the sender account to be killed (false), or transfer everything
       * except at least the existential deposit, which will guarantee to
       * keep the sender account alive (true).
       **/
      transferAll: AugmentedSubmittable<
        (
          dest:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          currencyId: u32 | AnyNumber | Uint8Array,
          keepAlive: bool | boolean | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, u32, bool]
      >;
      /**
       * Same as the [`transfer`] call, but with a check that the transfer
       * will not kill the origin account.
       *
       * 99% of the time you want [`transfer`] instead.
       *
       * The dispatch origin for this call must be `Signed` by the
       * transactor.
       *
       * - `dest`: The recipient of the transfer.
       * - `currency_id`: currency type.
       * - `amount`: free balance amount to tranfer.
       **/
      transferKeepAlive: AugmentedSubmittable<
        (
          dest:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array,
          currencyId: u32 | AnyNumber | Uint8Array,
          amount: Compact<u128> | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [MultiAddress, u32, Compact<u128>]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    tokenWrapper: {
      setWrappingFee: AugmentedSubmittable<
        (
          fee: u128 | AnyNumber | Uint8Array,
          intoPoolShareId: u32 | AnyNumber | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u128, u32]
      >;
      unwrap: AugmentedSubmittable<
        (
          fromPoolShareId: u32 | AnyNumber | Uint8Array,
          intoAssetId: u32 | AnyNumber | Uint8Array,
          amount: u128 | AnyNumber | Uint8Array,
          recipient: AccountId32 | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, u32, u128, AccountId32]
      >;
      wrap: AugmentedSubmittable<
        (
          fromAssetId: u32 | AnyNumber | Uint8Array,
          intoPoolShareId: u32 | AnyNumber | Uint8Array,
          amount: u128 | AnyNumber | Uint8Array,
          recipient: AccountId32 | string | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [u32, u32, u128, AccountId32]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
    treasury: {
      /**
       * Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
       * and the original deposit will be returned.
       *
       * May only be called from `T::ApproveOrigin`.
       *
       * # <weight>
       * - Complexity: O(1).
       * - DbReads: `Proposals`, `Approvals`
       * - DbWrite: `Approvals`
       * # </weight>
       **/
      approveProposal: AugmentedSubmittable<
        (proposalId: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>]
      >;
      /**
       * Put forward a suggestion for spending. A deposit proportional to the value
       * is reserved and slashed if the proposal is rejected. It is returned once the
       * proposal is awarded.
       *
       * # <weight>
       * - Complexity: O(1)
       * - DbReads: `ProposalCount`, `origin account`
       * - DbWrites: `ProposalCount`, `Proposals`, `origin account`
       * # </weight>
       **/
      proposeSpend: AugmentedSubmittable<
        (
          value: Compact<u128> | AnyNumber | Uint8Array,
          beneficiary:
            | MultiAddress
            | { Id: any }
            | { Index: any }
            | { Raw: any }
            | { Address32: any }
            | { Address20: any }
            | string
            | Uint8Array
        ) => SubmittableExtrinsic<ApiType>,
        [Compact<u128>, MultiAddress]
      >;
      /**
       * Reject a proposed spend. The original deposit will be slashed.
       *
       * May only be called from `T::RejectOrigin`.
       *
       * # <weight>
       * - Complexity: O(1)
       * - DbReads: `Proposals`, `rejected proposer account`
       * - DbWrites: `Proposals`, `rejected proposer account`
       * # </weight>
       **/
      rejectProposal: AugmentedSubmittable<
        (proposalId: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Compact<u32>]
      >;
      /**
       * Generic tx
       **/
      [key: string]: SubmittableExtrinsicFunction<ApiType>;
    };
  } // AugmentedSubmittables
} // declare module
